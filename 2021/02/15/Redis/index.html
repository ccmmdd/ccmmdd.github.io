<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Redis | betty bear</title><meta name="keywords" content="数据库"><meta name="author" content="betty bear,3025346417@qq.com"><meta name="copyright" content="betty bear"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="缓存缓存是为了调节速度不一致的两个或多个不同的物质的速度，在中间对速度较快的一方起到一个加速访问速度较慢的一方的作用比如 CPU 的一级、二级缓存是保存了 CPU 最近经常访问的数据，内存是保存 CPU 经常访问硬盘的数据，而且硬盘也有大小不一的缓存，甚至是物理服务器的 raid 卡有也缓存为了起到加速 CPU 访问硬盘数据的目的，因为 CPU 的速度太快了， CPU 需要的数据硬盘往往不能在短时">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://xczf.shop/2021/02/15/Redis/index.html">
<meta property="og:site_name" content="betty bear">
<meta property="og:description" content="缓存缓存是为了调节速度不一致的两个或多个不同的物质的速度，在中间对速度较快的一方起到一个加速访问速度较慢的一方的作用比如 CPU 的一级、二级缓存是保存了 CPU 最近经常访问的数据，内存是保存 CPU 经常访问硬盘的数据，而且硬盘也有大小不一的缓存，甚至是物理服务器的 raid 卡有也缓存为了起到加速 CPU 访问硬盘数据的目的，因为 CPU 的速度太快了， CPU 需要的数据硬盘往往不能在短时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xczf.shop/image/12.jpg">
<meta property="article:published_time" content="2021-02-15T11:00:41.000Z">
<meta property="article:modified_time" content="2023-12-21T14:26:08.109Z">
<meta property="article:author" content="betty bear">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xczf.shop/image/12.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://xczf.shop/2021/02/15/Redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: betty bear","link":"链接: ","source":"来源: betty bear","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-21 22:26:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="betty bear" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/cate%EF%BC%9Agories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 便签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/12.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">betty bear</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 便签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-15T11:00:41.000Z" title="发表于 2021-02-15 19:00:41">2021-02-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-21T14:26:08.109Z" title="更新于 2023-12-21 22:26:08">2023-12-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/cate%EF%BC%9Agories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是为了<strong>调节速度不一致的两个或多个不同的物质的速度，在中间对速度较快的一方起到一个加速访问速度较慢的一方的作用</strong><br>比如 CPU 的一级、二级缓存是保存了 CPU 最近经常访问的数据，内存是保存 CPU 经常访问硬盘的数据，而且硬盘也有大小不一的缓存，甚至是物理服务器的 raid 卡有也缓存为了起到加速 CPU 访问硬盘数据的目的，因为 CPU 的速度太快了， CPU 需要的数据硬盘往往不能在短时间内满足 CPU 的需求。<br><img src="/image/redis/1.jpg" alt="CPU"></p>
<h3 id="硬件缓存"><a href="#硬件缓存" class="headerlink" title="硬件缓存"></a>硬件缓存</h3><ul>
<li>CPU缓存<br>CPU缓存(L1的数据缓存和L1的指令缓存)、二级缓存、三级缓存</li>
<li>磁盘相关缓存<br>磁盘缓存：Disk Cache<br><strong>磁盘阵列缓存</strong>：Raid Cache，可使用电池防止断电丢失数据<h3 id="系统缓存"><a href="#系统缓存" class="headerlink" title="系统缓存"></a>系统缓存</h3><h4 id="buffer-与-cache"><a href="#buffer-与-cache" class="headerlink" title="buffer 与 cache"></a>buffer 与 cache</h4>buffer：缓冲也叫写<strong>缓冲</strong>，一般用于<strong>写</strong>操作，可以将数据先写入内存再写入磁盘，buffer 一般用于写缓冲，用于解决不同介质的速度不一致的缓冲，先将数据临时写入到里自己最近的地方，以提高写入速度，CPU 会把数据先写到内存的磁盘缓冲区，然后就认为数据已经写入完成，然后由内核在后续的时间再写入磁盘，所以服务器突然断电会丢失内存中的部分数据。<br>cache：缓存也叫读<strong>缓存</strong>，一般用于<strong>读</strong>操作，CPU 读文件从内存读，如果内存没有就先从硬盘读到内存再读到 CPU，将需要频繁读取的数据放在里自己最近的缓存区域，下次读取的时候即可快速读取。<h3 id="用户层缓存"><a href="#用户层缓存" class="headerlink" title="用户层缓存"></a>用户层缓存</h3><h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4>默认为 60 秒，即 60 秒之内在访问同一个域名就不再进行 DNS 解析<br><strong>查看 chrome 浏览器的 DNS 缓存：chrome:&#x2F;&#x2F;net-internals&#x2F;#dns</strong><br>DNS 预获取，仅在HTML5中支持，当一个页面中包含多个域名的时候浏览器会先尝试解析域名并进行缓存，之后再使用的时候即可直接使用不需要再进行DNS 解析<h4 id="浏览器缓存过期机制"><a href="#浏览器缓存过期机制" class="headerlink" title="浏览器缓存过期机制"></a>浏览器缓存过期机制</h4><a target="_blank" rel="noopener" href="https://www.cnblogs.com/struggle-1216/p/12116090.html">https://www.cnblogs.com/struggle-1216/p/12116090.html</a><h4 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h4>Cookie是访问某些网站以后在本地存储的一些网站相关的信息，下次再访问的时候减少一些步骤,比如加密后的账户名密码等信息<br>Cookies是服务器在客户端浏览器上存储的小段文本并随每一个请求发送至同一个服务器，是一种实现客户端保持状态的方案。<br>session称为会话信息，位于web服务器上，主要负责访问者与网站之间的交互，当浏览器请求http地址时，可以基于之前的session实现会话保持、session共享等。<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3>内容分发网络（Content Delivery Network，CDN）是建立并覆盖在承载网上，由不同区域的服务器组成的分布式网络。将源站资源缓存到全国各地的边缘服务器，利用全球调度系统使用户能够就近获取，有效降低访问延迟，降低源站压力,提升服务可用性。<h4 id="302实现转发请求重定向至最优服务器集群"><a href="#302实现转发请求重定向至最优服务器集群" class="headerlink" title="302实现转发请求重定向至最优服务器集群"></a>302实现转发请求重定向至最优服务器集群</h4>中国网络较为复杂，依赖DNS就近解析的调度，仍然会存在部分请求调度失效、调度生效慢等问题。<br>例：腾讯云利用在全国部署的302重定向服务器集群，能够为每一个请求实时决策最优的服务器资源，精准解决小运营商的调度问题，提升用户访问质量, 能最快地把用户引导到最优的服务器节点上，避开性能差或者异常的节点。<h4 id="CDN流程"><a href="#CDN流程" class="headerlink" title="CDN流程"></a>CDN流程</h4><img src="/image/redis/2.jpg" alt="CDN流程"><br>1.用户向<a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a> 下的某图片资源（如：1.jpg）发起请求，会先向 Local DNS 发起域名解析请求。</li>
</ul>
<ol start="2">
<li>当 Local DNS 解析<a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a> 时，会发现已经配置了<br>CNAME<a target="_blank" rel="noopener" href="http://www.test.com.cdn.dnsv1.com/">www.test.com.cdn.dnsv1.com</a> ，解析请求会发送至 Tencent DNS（GSLB），GSLB 为腾讯云自主研发的调度体系，会为请求分配最佳节点 IP。</li>
<li>Local DNS 获取 Tencent DNS 返回的解析 IP。</li>
<li>用户获取解析 IP。</li>
<li>用户向获取的 IP 发起对资源 1.jpg 的访问请求。</li>
<li>若该 IP 对应的节点缓存有 1.jpg，则会将数据直接返回给用户（10），此时请求结束。若该节点未缓存 1.jpg，则节点会向业务源站发起对 1.jpg 的请求（6、7、8），获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点（9），并返回给用户（10），此时请求结束。<h3 id="应用层缓存"><a href="#应用层缓存" class="headerlink" title="应用层缓存"></a>应用层缓存</h3>Nginx、PHP等web服务可以设置应用缓存以加速响应用户请求，另外有些解释性语言，比如：PHP&#x2F;Python&#x2F;Java不能直接运行，需要先编译成字节码，但字节码需要解释器解释为机器码之后才能执行，因此字节码也是一种缓存，有时候还会出现程序代码上线后字节码没有更新的现象。<h3 id="数据层缓存"><a href="#数据层缓存" class="headerlink" title="数据层缓存"></a>数据层缓存</h3></li>
</ol>
<ul>
<li>分布式缓存服务<br>Redis<br>Memcached</li>
<li>数据库<br>MySQL 查询缓存<br>innodb缓存、MyISAM缓存</li>
</ul>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>官网：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a><br>Redis是一个开源的、遵循BSD协议的、基于内存的而且目前比较流行的键值数据库(key-value<br>database)，是一个非关系型数据库，redis 提供将内存通过网络远程共享的一种服务。<br>久性等功能。<br><strong>Redis 在高并发、低延迟环境要求比较高的环境使用量非常广泛</strong><br><img src="/image/redis/3.jpg" alt="数据操作"></p>
<ul>
<li>应用场景<br>Session 共享：常见于web集群中的Tomcat或者PHP中多web服务器session共享<br>缓存：数据查询、电商网站商品信息、新闻内容<br>计数器：访问排行榜、商品浏览数等和次数相关的数值统计场景 不蒜子<br>微博&#x2F;微信社交场合：共同好友,粉丝数,关注,点赞评论等<br>消息队列：ELK的日志缓存、部分业务的订阅发布系统<br>地理位置: 基于GEO(地理信息定位),实现摇一摇,附近的人,外卖等功能<h3 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h3>下载地址：<a target="_blank" rel="noopener" href="http://download.redis.io/releases/">http://download.redis.io/releases/</a><h4 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release &amp;&amp; yum info redis</span><br><span class="line">yum -y install redis psmisc</span><br><span class="line">systemctl <span class="built_in">enable</span> --now redis &amp;&amp; pstree -p | grep redis</span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure>
<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4>redis源码包：<a target="_blank" rel="noopener" href="http://download.redis.io/releases/">http://download.redis.io/releases/</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make gcc tcl</span><br><span class="line">wget https://download.redis.io/releases/redis-5.0.9.tar.gz</span><br><span class="line">tar xf redis-5.0.9.tar.gz</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">cd</span> redis-5.0.9/</span><br><span class="line"><span class="built_in">cd</span> src/</span><br><span class="line">make</span><br><span class="line">make PREFIX=/apps/redis install</span><br><span class="line"><span class="comment"># 配置变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PATH=/apps/redis/bin:<span class="variable">$PATH</span>&quot;</span> &gt; /etc/profile.d/redis.sh</span><br><span class="line">. /etc/profile.d/redis.sh</span><br><span class="line"><span class="comment"># 准备相关目录和文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /apps/redis/&#123;etc,<span class="built_in">log</span>,data,run&#125;</span><br><span class="line"><span class="built_in">cp</span> ~/redis-5.0.9/redis.conf /apps/redis/etc/</span><br></pre></td></tr></table></figure>
<h4 id="命令软链接"><a href="#命令软链接" class="headerlink" title="命令软链接"></a>命令软链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /apps/redis/bin/ /usr/bin/</span><br></pre></td></tr></table></figure>
<h4 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /apps/redis/etc/redis.conf <span class="comment"># 6379</span></span><br></pre></td></tr></table></figure>
<h4 id="启动多实例"><a href="#启动多实例" class="headerlink" title="启动多实例"></a>启动多实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /apps/redis/6380</span><br><span class="line"><span class="built_in">cp</span> -ar /apps/redis/* /apps/redis/6380/</span><br><span class="line">vim /apps/redis/6380/etc/redis.conf</span><br><span class="line">******************************</span><br><span class="line">port 6380</span><br><span class="line">******************************</span><br><span class="line">redis-server --port 6380</span><br><span class="line">redis-cli -p 6380</span><br></pre></td></tr></table></figure>
<h4 id="解决启动时三个告警"><a href="#解决启动时三个告警" class="headerlink" title="解决启动时三个告警"></a>解决启动时三个告警</h4>redis配置文件的参数和内核参数不匹配, 因此还需要修改配置参数, 否则启动时会有警告, 但是<br>并不影响使用<h5 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h5>backlog参数控制的是三次握手的时候server端收到client.ack确认号之后的队列值，即全连接<br>队列<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.somaxconn = 1024&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<h5 id="vm-overcommit-memory"><a href="#vm-overcommit-memory" class="headerlink" title="vm.overcommit_memory"></a>vm.overcommit_memory</h5>0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请<br>允许；否则，内存申请失败，并把错误返回给应用进程。<br>1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何<br>2 表示内核允许分配超过所有物理内存和交换空间总和的内存<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vm.overcommit_memory=1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<h5 id="transparent-huge-pages"><a href="#transparent-huge-pages" class="headerlink" title="transparent huge pages"></a>transparent huge pages</h5>警告：您在内核中启用了透明大页面（THP,不同于一般内存页的4k为2M）支持。 这将在<br>Redis中造成延迟和内存使用问题。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&quot;</span> &gt;&gt; /etc/rc.d/rc.local</span><br><span class="line"><span class="built_in">chmod</span> +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>
<h4 id="systemctl管理redis"><a href="#systemctl管理redis" class="headerlink" title="systemctl管理redis"></a>systemctl管理redis</h4></li>
<li>创建redis用户<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -r -s /sbin/nologin redis</span><br><span class="line"><span class="built_in">chown</span> -R redis.redis /apps/redis/</span><br></pre></td></tr></table></figure></li>
<li>编辑 redis 服务启动文件 来源：yum安装的方式 &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;redis.service<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Redis persistent key-value database</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/apps/redis/bin/redis-server /apps/redis/etc/redis.conf --</span><br><span class="line">supervised systemd</span><br><span class="line">ExecStop=/bin/kill -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line">Type=notify</span><br><span class="line">User=redis</span><br><span class="line">Group=redis</span><br><span class="line">RuntimeDirectory=redis</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li>
<li>验证<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl damen-deload</span><br><span class="line">systemctl <span class="built_in">enable</span> --now redis</span><br><span class="line">ss -tnl</span><br></pre></td></tr></table></figure>
<h4 id="设置密码登录"><a href="#设置密码登录" class="headerlink" title="设置密码登录"></a>设置密码登录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /apps/redis/etc/redis.conf</span><br><span class="line"><span class="comment"># 解除下面一行的注释 requirepass foobared</span></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line">requirepass password</span><br></pre></td></tr></table></figure>
<h4 id="程序连接"><a href="#程序连接" class="headerlink" title="程序连接"></a>程序连接</h4>redis 支持多种开发语言访问<a target="_blank" rel="noopener" href="https://redis.io/clients">https://redis.io/clients</a><h5 id="shell-连接方式"><a href="#shell-连接方式" class="headerlink" title="shell 连接方式"></a>shell 连接方式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim redis_test.sh</span><br><span class="line">**********************</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">NUM=`seq 1 10000`</span><br><span class="line">PASS=centos</span><br><span class="line">for i in $&#123;NUM&#125;;do</span><br><span class="line">redis-cli -h 127.0.0.1 -a &quot;$PASS&quot; --no-auth-warning set key-$&#123;i&#125; value-$&#123;i&#125;</span><br><span class="line">echo &quot;key-$&#123;i&#125; value-$&#123;i&#125; 写入完成&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;一万个key写入到Redis完成&quot;</span><br></pre></td></tr></table></figure>
<h5 id="python-连接方式"><a href="#python-连接方式" class="headerlink" title="python 连接方式"></a>python 连接方式</h5></li>
<li>安装python运行环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install python3 python3-redis</span><br></pre></td></tr></table></figure></li>
<li>编写python程序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment">#import time</span></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&quot;127.0.0.1&quot;</span>,port=<span class="number">6379</span>,password=<span class="string">&quot;centos&quot;</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&quot;k%d&quot;</span> % i,<span class="string">&quot;v%d&quot;</span> % i)</span><br><span class="line"><span class="comment"># time.sleep(1)</span></span><br><span class="line">data=r.get(<span class="string">&quot;k%d&quot;</span> % i)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3>Redis 虽然是一个内存级别的缓存程序，也就是redis 是使用内存进行数据的缓存的，但是其可以将内存的数据按照一定的策略保存到硬盘上，从而实现数据持久保存的目的<br>目前redis支持两种不同方式的数据持久化保存机制，分别是RDB和AOF<br><strong>如果主要充当缓存功能,或者可以承受数分钟数据的丢失, 通常生产环境一般只需启用RDB即可,此也是默认值</strong><br>如果数据需要持久保存,一点不能丢失,<strong>可以选择同时开启RDB和AOF,一般不建议只开启AOF</strong></li>
</ul>
<h4 id="RDB-模式"><a href="#RDB-模式" class="headerlink" title="RDB 模式"></a>RDB 模式</h4><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="/image/redis/4.jpg" alt="工作原理"></p>
<h5 id="实现快照"><a href="#实现快照" class="headerlink" title="实现快照"></a>实现快照</h5><p>基于时间的快照，其默认只保留当前最新的一次快照，特点是执行速度比较快，缺点是可能会丢失从上次快照到当前时间点之间未做快照的数据<br><img src="/image/redis/5.jpg" alt="快照"><br>Redis从master主进程先fork出一个子进程，使用写时复制机制，子进程将内存的数据保存为一个临时文件<br>当数据保存完成之后再将上一次保存的RDB文件替换掉，然后关闭子进程，这样可以保证每一次做RDB快照保存的数据都是完整的<br>因为直接替换RDB文件的时候,可能会出现突然断电等问题,而导致RDB文件还没有保存完整就因为突然关机停止保存,而导致数据丢失的情况.后续可以手动将每次生成的RDB文件进行备份，这样可以最大化保存历史数据</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>RDB快照保存了某个时间点的数据，可以通过脚本执行redis指令bgsave(非阻塞，后台执行)或者save(会阻塞写操作,不推荐)命令自定义时间点备份，可以保留多个备份，当出现问题可以恢复到不同时间点的版本,很适合备份,并且此文件格式也支持有不少第三方工具可以进行后续的数据分析<br><strong>RDB可以最大化Redis的性能</strong>，父进程在保存 RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘工&#x2F;0操作。<br>RDB在大量数据,比如几个G的数据，恢复的速度比AOF的快</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><strong>不能实时保存数据</strong>，可能会丢失自上一次执行RDB备份到当前的内存数据<br>当数据量非常大的时候，从父进程fork子进程进行保存至RDB文件时需要一点时间，可能是毫秒或者秒，取决于磁盘IO性能<br>在数据集比较庞大时，fork()可能会非常耗时，造成服务器在一定时间内停止处理客户端﹔如果数据集非常巨大，并且CPU时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒或更久。<br>虽然 AOF重写也需要进行fork()，但无论AOF重写的执行间隔有多长，数据的持久性都不会有任何损失。</p>
<h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><p><img src="/image/redis/6.jpg" alt="重写"></p>
<ol>
<li>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进 程，如RDB&#x2F;AOF子进程，如果存在bgsave命令直接返回。</li>
<li>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通 过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒。</li>
<li>父进程fork完成后，bgsave命令返回“Background saving started”信息 并不再阻塞父进程，可以继续响应其他命令。</li>
<li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的 时间，对应info统计的rdb_last_save_time选项。</li>
<li>进程发送信号给父进程表示完成，父进程更新统计信息<h4 id="AOF-模式"><a href="#AOF-模式" class="headerlink" title="AOF 模式"></a>AOF 模式</h4><strong>AOF 模式默认是关闭</strong><br>按照操作顺序依次将操作追加到指定的日志文件末尾<br>同时<strong>启用RDB和AOF,进行恢复时,默认AOF文件优先级高于RDB文件</strong>,即会使用AOF文件进行恢复<h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><img src="/image/redis/7.jpg" alt="工作原理"><h5 id="重写-1"><a href="#重写-1" class="headerlink" title="重写"></a>重写</h5>将一些重复的,可以合并的,过期的数据重新写入一个新的AOF文件,从而节约AOF备份占用的硬盘空间,也能加速恢复过程<br>可以手动执行bgrewriteaof 触发AOF,或定义自动rewrite策略<br><img src="/image/redis/8.jpg" alt="重写"><br>1.执行AOF重写请求。<br>2.父进程执行fork创建子进程，开销等同于bgsave过程。<br>3.1主进程fork操作完成后，继续响应其他命令。所有修改命令依然写 入AOF缓冲区并根据appendfsync策略同步到硬盘，保证原有AOF机制正确性。<br>3.2由于fork操作运用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然响应命令，Redis使用“AOF重写缓冲区”保存这部分新数据，防止新AOF文件生成期间丢失这部分数据。<br>4.子进程根据内存快照，按照命令合并规则写入到新的AOF文件。每次批量写入硬盘数据量由配置aof-rewrite-incremental-fsync控制，默认为32MB，防止单次刷盘数据过多造成硬盘阻塞。<br>5.1新AOF文件写入完成后，子进程发送信号给父进程，父进程更新 统计信息，具体见info persistence下的aof _ * 相关统计。<br>5.2父进程把AOF重写缓冲区的数据写入到新的AOF文件。<br>5.3使用新AOF文件替换老文件，完成AOF重写。<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><strong>数据安全性相对较高</strong>，根据所使用的fsync策略(fsync是同步内存中redis所有已经修改的文件到存储设备)，默认是appendfsync everysec，即每秒执行一次 fsync,在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据<br><strong>写入操作采用的是append模式，因此在写入过程中不需要seek, 即使出现宕机现象，也不会破坏日志文件中已经存在的内容</strong>。然而如果本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，可以<strong>通过 redis-check-aof 工具来解决数据一致性的问题</strong><br><strong>Redis可以在 AOF文件体积变得过大时，自动地在后台对AOF进行重写</strong>,重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建新 AOF文件的过程中，append模式不断的将修改数据追加到现有的 AOF文件里面，即使重写过程中发生停机，现有的 AOF文件也不会丢失。而一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作。<br><strong>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。</strong><br><strong>AOF文件有序地保存了对数据库执行的所有写入操作</strong>，这些写入操作以Redis协议的格式保存，因此 AOF文件的内容非常容易被人读懂，对文件进行分析(parse)也很轻松。<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5>即使有些操作是重复的也会全部记录，<strong>AOF 的文件大小要大于 RDB 格式的文件</strong><br>AOF 在<strong>恢复大数据集时的速度比 RDB 的恢复速度要慢</strong><br>根据fsync策略不同,<strong>AOF速度可能会慢于RDB</strong><br>bug 出现的可能性更多<h3 id="Redis-常用命令"><a href="#Redis-常用命令" class="headerlink" title="Redis 常用命令"></a>Redis 常用命令</h3>开发文档：<a target="_blank" rel="noopener" href="http://redisdoc.com/">http://redisdoc.com/</a><h4 id="INFO-显示当前节点redis运行状态信息"><a href="#INFO-显示当前节点redis运行状态信息" class="headerlink" title="INFO 显示当前节点redis运行状态信息"></a>INFO 显示当前节点redis运行状态信息</h4><h4 id="SELECT-切换数据库"><a href="#SELECT-切换数据库" class="headerlink" title="SELECT 切换数据库"></a>SELECT 切换数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 0</span><br><span class="line">select 1</span><br></pre></td></tr></table></figure>
<h4 id="KEYS-查看当前库下的所有key"><a href="#KEYS-查看当前库下的所有key" class="headerlink" title="KEYS 查看当前库下的所有key"></a>KEYS 查看当前库下的所有key</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS *</span><br></pre></td></tr></table></figure>
<h4 id="BGSAVE-手动在后台执行RDB持久化操作"><a href="#BGSAVE-手动在后台执行RDB持久化操作" class="headerlink" title="BGSAVE 手动在后台执行RDB持久化操作"></a>BGSAVE 手动在后台执行RDB持久化操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#交互式执行</span></span><br><span class="line">127.0.0.1:6379[1]&gt; BGSAVE</span><br><span class="line">Background saving started</span><br><span class="line"><span class="comment">#非交互式执行</span></span><br><span class="line">redis-cli -a centos --no-auth-warning bgsave</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>
<h4 id="DBSIZE-返回当前库下的所有key-数量"><a href="#DBSIZE-返回当前库下的所有key-数量" class="headerlink" title="DBSIZE 返回当前库下的所有key 数量"></a>DBSIZE 返回当前库下的所有key 数量</h4><h4 id="FLUSHDB-强制清空当前库中的所有key-慎用！"><a href="#FLUSHDB-强制清空当前库中的所有key-慎用！" class="headerlink" title="FLUSHDB 强制清空当前库中的所有key 慎用！"></a>FLUSHDB 强制清空当前库中的所有key 慎用！</h4><h4 id="FLUSHALL-强制清空当前redis服务器所有数据库中的所有数据-慎用！"><a href="#FLUSHALL-强制清空当前redis服务器所有数据库中的所有数据-慎用！" class="headerlink" title="FLUSHALL 强制清空当前redis服务器所有数据库中的所有数据 慎用！"></a>FLUSHALL 强制清空当前redis服务器所有数据库中的所有数据 慎用！</h4><h4 id="SHUTDOWN-停止所有客户端"><a href="#SHUTDOWN-停止所有客户端" class="headerlink" title="SHUTDOWN 停止所有客户端"></a>SHUTDOWN 停止所有客户端</h4>如果有至少一个保存点在等待，执行 SAVE 命令<br>如果 AOF 选项被打开，更新 AOF 文件<br>关闭 redis 服务器(server)<br><strong>如果持久化被打开的话， SHUTDOWN 命令会保证服务器正常关闭而不丢失任何数据</strong><h3 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h3><h4 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h4>redis中所有的 key 的类型都是字符串。常用于保存 Session</li>
</ol>
<ul>
<li>添加一个key<br>set 指令可以创建一个key 并赋值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set key1 value1</span></span><br><span class="line"><span class="built_in">set</span> title ceo ex 5 <span class="comment">#设置自动过期时间为5秒 #大小写敏感</span></span><br><span class="line"><span class="built_in">set</span> name sls nx <span class="comment">#不存在才设置</span></span><br><span class="line"><span class="built_in">set</span> name sls xx <span class="comment">#存在才设置进行覆盖</span></span><br></pre></td></tr></table></figure></li>
<li>获取一个和多个key<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get name <span class="comment"># 一个</span></span><br><span class="line"> <span class="comment"># 多个</span></span><br><span class="line">mget name age</span><br><span class="line">keys *</span><br><span class="line">keys k*</span><br></pre></td></tr></table></figure></li>
<li>删除一个和多个key<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del name</span><br><span class="line">del age NAME</span><br></pre></td></tr></table></figure></li>
<li>批量设置多个key<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset k1 v1 k2 v2</span><br></pre></td></tr></table></figure></li>
<li>追加数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append k2 <span class="string">&quot; append new value&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>设置新值并返回旧值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset name sls</span><br></pre></td></tr></table></figure></li>
<li>返回字符串 key 对应值的字节数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen name</span><br></pre></td></tr></table></figure></li>
<li>判断 key 是否存在<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists name</span><br></pre></td></tr></table></figure></li>
<li>查看 key 的过期时间<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -1  #返回值表示永不过期，默认创建的key是永不过期，重新对key赋值，也会从有剩余生命周期变成永不过期</span></span><br><span class="line"><span class="comment"># -2  #返回值表示没有此key</span></span><br><span class="line"><span class="comment"># num #key的剩余有效期</span></span><br><span class="line">ttl name</span><br></pre></td></tr></table></figure></li>
<li>重新设置key的过期时间<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire name 30</span><br></pre></td></tr></table></figure></li>
<li>取消key的过期时间<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist name <span class="comment"># 使键永久存在</span></span><br></pre></td></tr></table></figure></li>
<li>数值递增，递减<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incr num <span class="comment"># 递增</span></span><br><span class="line">decr num</span><br></pre></td></tr></table></figure>
<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h4>列表是一个双向可读写的管道，其头部是左侧，尾部是右侧，一个列表最多可以包含2^32-1</li>
<li>生成列表并插入数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpush name abc a b c</span><br><span class="line">lpush name abc c b a</span><br></pre></td></tr></table></figure></li>
<li>向列表追加数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpush name abc</span><br><span class="line">rpush name abc</span><br></pre></td></tr></table></figure></li>
<li>获取列表长度(元素个数)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen name</span><br></pre></td></tr></table></figure></li>
<li>获取列表指定位置数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lindex list1 0 <span class="comment">#获取0编号的元素</span></span><br><span class="line">lindex list1 -1 <span class="comment">#获取最后一个的元素</span></span><br><span class="line">lrange list1 0 -1 <span class="comment">#所有元素</span></span><br></pre></td></tr></table></figure></li>
<li>修改列表指定索引值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange list1 0 -1</span><br></pre></td></tr></table></figure></li>
<li>移除列表数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop list1 <span class="comment">#弹出左边第一个元素，即删除第一个</span></span><br><span class="line">rpop list1 <span class="comment">#弹出右边第一个元素，即删除最后一个</span></span><br></pre></td></tr></table></figure></li>
<li>删除list<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del list1</span><br></pre></td></tr></table></figure>
<h4 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h4>Set 是 String 类型的无序集合，集合中的成员是唯一的，这就意味着集合中不能出现重复的数据</li>
<li>生成集合key<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd set2 v2 v3</span><br></pre></td></tr></table></figure></li>
<li>追加数值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd set1 v3 v4 v5</span><br></pre></td></tr></table></figure></li>
<li>查看集合的所有数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers set1</span><br></pre></td></tr></table></figure></li>
<li>删除集合中的元素<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sadd goods mobile car laptop</span><br><span class="line">srem goods car</span><br></pre></td></tr></table></figure></li>
<li>获取集合的交集，并集，差集<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter set1 set2 <span class="comment"># 交集</span></span><br><span class="line">sunion set1 set2 <span class="comment"># 并集</span></span><br><span class="line">sdiff set1 set2 <span class="comment"># 差集</span></span><br></pre></td></tr></table></figure>
<h4 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合 sorted set"></a>有序集合 sorted set</h4>有序集合的成员是唯一的,但分数(score)却可以重复</li>
<li>生成有序集合<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zadd zset1 1 v1 <span class="comment">#分数为1</span></span><br><span class="line">zadd zset1 2 v3 <span class="comment">#分数可重复，元素值不可以重复</span></span><br></pre></td></tr></table></figure></li>
<li>有序集合实现排行榜<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zadd phb 90 xwz 95 tj 30 sg</span><br><span class="line">zrange phb 0 -1 <span class="comment">#正序排序后显示集合内所有的key，score从小到大显示</span></span><br><span class="line">zrevrange phb 0 -1 <span class="comment">#倒叙排序后显示集合内所有的key，score从大到小显示</span></span><br><span class="line">zrevrange phb 0 -1 withscores <span class="comment">#正序显示指定集合内所有key和得分情况</span></span><br></pre></td></tr></table></figure></li>
<li>获取集合的个数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard phb</span><br></pre></td></tr></table></figure></li>
<li>基于索引返回数值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange phb 0 2</span><br></pre></td></tr></table></figure></li>
<li>返回某个数值的索引(排名)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrank phb sg</span><br></pre></td></tr></table></figure></li>
<li>获取分数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscore phb sg</span><br></pre></td></tr></table></figure></li>
<li>删除元素<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem phb sg tj</span><br></pre></td></tr></table></figure>
<h4 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 hash"></a>哈希 hash</h4>hash 是一个string类型的字段(field)和值(value)的映射表</li>
<li>生成 hash key<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hset 9527 name sg age 3</span><br><span class="line"><span class="comment"># 增加字段</span></span><br><span class="line">hset 9527 gender man</span><br></pre></td></tr></table></figure></li>
<li>获取hash key的对应字段的值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget 9527 name</span><br></pre></td></tr></table></figure></li>
<li>删除一个hash key 的对应字段<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel 9527 age</span><br></pre></td></tr></table></figure></li>
<li>批量设置hash key的多个field和value<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset 1024 name xls age 28 city changzhou</span><br></pre></td></tr></table></figure></li>
<li>获取hash中指定字段的值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget 1024 name city</span><br></pre></td></tr></table></figure></li>
<li>获取hash中的所有字段名field，value<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hkeys 1024 <span class="comment"># field</span></span><br><span class="line">hvals 1024 <span class="comment"># value</span></span><br><span class="line">hgetall 1024 <span class="comment"># field + value</span></span><br></pre></td></tr></table></figure></li>
<li>删除 hash<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del 1024</span><br><span class="line">exists 1024</span><br></pre></td></tr></table></figure>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3>消息队列: 把要传输的数据放在队列中，可以实现多个系统之间的解耦,异步,削峰&#x2F;限流等<br><strong>消息队列主要分为生产者&#x2F;消费者模式和发布者&#x2F;订阅者模式,这两种模式Redis都支持</strong><h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4>生产者&#x2F;消费者(Producer&#x2F;Consumer)模式下，上层应用接收到的外部请求后开始处理其当前步骤的操作，在执行完成后将已经完成的操作发送至指定的频道(channel,逻辑队列)当中，并由其下层的应用监听该频道并继续下一步的操作，如果其处理完成后没有下一步的操作就直接返回数据给外部请求，如果还有下一步的操作就再将任务发布到另外一个频道，由另外一个消费者继续监听和处理。<br><strong>生产者消费者模式下，多个消费者同时监听一个队列，但是一个消息只能被最先抢到消息的消费者消费，即消息任务是一次性读取和处理</strong><br><img src="/image/redis/9.jpg" alt="生产者消费者模式"><h4 id="发布者订阅模式"><a href="#发布者订阅模式" class="headerlink" title="发布者订阅模式"></a>发布者订阅模式</h4>发布者订阅者模式下，发布者将消息发布到指定的channel里面，凡是监听该channel的消费者都会收到同样的一份消息<br><img src="/image/redis/10.jpg" alt="发布者订阅模式"></li>
<li>订阅者监听频道<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅者监听频道</span></span><br><span class="line">subscribe channel1</span><br><span class="line"><span class="comment"># 订阅多个频道</span></span><br><span class="line">subscribe channel1 channel2</span><br><span class="line"><span class="comment"># 订阅所有频道</span></span><br><span class="line">psubscribe *  <span class="comment"># 支持通配符*</span></span><br><span class="line"><span class="comment"># 取消订阅</span></span><br><span class="line">unsubscribe channel1</span><br></pre></td></tr></table></figure>
<h3 id="redis主从复制"><a href="#redis主从复制" class="headerlink" title="redis主从复制"></a>redis主从复制</h3>Redis可以实现单机的数据持久化，但无论是RDB也好或者AOF也好，都解决不了单点宕机问题，即一旦单台 redis服务器本身出现系统故障、硬件故障等问题后，就会直接造成数据的丢失<br><img src="/image/redis/11.jpg" alt="主从复制架构"><br>一个master可以有多个slave<br>一个slave只能有一个master<br>数据流向是单向的，master到slave<h4 id="实现主从复制"><a href="#实现主从复制" class="headerlink" title="实现主从复制"></a>实现主从复制</h4><strong>Redis Slave也要开启持久化并设置和master同样的连接密码，因为后期slave会有提升为master的可能,Slave 端切换master同步后会丢失之前的所有数据,而通过持久化可以恢复数据</strong><br><strong>默认redis状态为master，需要转换为slave角色并指向master服务器的IP+PORT+Password</strong><h5 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h5></li>
<li>master上设置key1<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a centos</span><br><span class="line">info replication</span><br><span class="line"><span class="built_in">set</span> key1 v1-master</span><br><span class="line">get key1 <span class="comment"># &quot;v1-master&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>在slave1上执行，登录，设置key1<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a centos --no-auth-warning</span><br><span class="line">info replication</span><br><span class="line"><span class="built_in">set</span> key1 v1-slave1</span><br><span class="line">get key1 <span class="comment"># &quot;v1-slave1&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>slave2上也设置相同的key1，但值不同<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a centos --no-auth-warning</span><br><span class="line">info replication</span><br><span class="line"><span class="built_in">set</span> key1 v1-slave2</span><br><span class="line">get key1 <span class="comment"># &quot;v1-slave2&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>所有的slave上设置master的IP和端口，4.0版本之前的指令为slaveof<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slave1</span></span><br><span class="line">replicaof 192.168.189.10 6379</span><br><span class="line">config <span class="built_in">set</span> masterauth centos <span class="comment"># 在slave上设置master的密码，才可以同步</span></span><br><span class="line">info replication</span><br><span class="line"><span class="comment"># role:slave #角色变为slave</span></span><br><span class="line"><span class="comment"># master_host:192.168.189.10 #指向master</span></span><br><span class="line">get key1 <span class="comment"># # 查看数据是否同步成功 &quot;v1-master&quot;</span></span><br><span class="line"><span class="comment"># slave2</span></span><br><span class="line">replicaof 192.168.175.10 6379</span><br><span class="line">config <span class="built_in">set</span> masterauth centos</span><br><span class="line">get key1</span><br><span class="line"><span class="comment"># master上可以看到所有slave的信息 info replication</span></span><br><span class="line"><span class="comment"># slave0:ip=192.168.189.30,port=6379,state=online,offset=224,lag=1</span></span><br><span class="line"><span class="comment"># slave1:ip=192.168.189.20,port=6379,state=online,offset=224,lag=0</span></span><br></pre></td></tr></table></figure></li>
<li>删除主从同步<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replicaof no one</span><br><span class="line">info replication <span class="comment"># 角色变回了master</span></span><br></pre></td></tr></table></figure>
<h5 id="修改slave节点配置文件"><a href="#修改slave节点配置文件" class="headerlink" title="修改slave节点配置文件"></a>修改slave节点配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slave1，2上</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;replicaof 192.168.189.10 6379&quot;</span> &gt;&gt; /apps/redis/etc/redis.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;masterauth centos&quot;</span> &gt;&gt; /apps/redis/etc/redis.conf</span><br><span class="line">systemctl restart redis</span><br></pre></td></tr></table></figure>
<h4 id="主从复制故障恢复"><a href="#主从复制故障恢复" class="headerlink" title="主从复制故障恢复"></a>主从复制故障恢复</h4></li>
<li>slave节点故障和恢复，client指向另一个从节点即可，并及时修复故障从节点<br><img src="/image/redis/12.jpg" alt="slave节点故障"></li>
<li>master节点故障和恢复，提升slave为新的master<br><strong>master故障后只能手动提升一个slave为新master，不支持自动切换。master的切换会导致master_replid发生变化，slave之前的master_replid就和当前master不一致从而会引发所有slave的全量同步</strong><br><img src="/image/redis/13.jpg" alt="master节点故障"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 192.168.189.10故障，提升192.168.189.20为新的master</span></span><br><span class="line">systemctl stop redis <span class="comment"># 10 redis stop</span></span><br><span class="line"><span class="comment"># 停止slave1(192.168.189.20)同步并提升为新的master</span></span><br><span class="line">replicaof no one</span><br><span class="line"><span class="built_in">set</span> keytest1 vtest1 <span class="comment"># OK</span></span><br><span class="line"><span class="comment"># 修改所有的slave指向新的master节点</span></span><br><span class="line">replicaof 192.168.189.20 6379</span><br><span class="line">config <span class="built_in">set</span> masterauth centos</span><br><span class="line"><span class="built_in">set</span> key100 v100 <span class="comment"># only read</span></span><br><span class="line">get keytest1 <span class="comment"># &quot;vtest1&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="redis的级联复制"><a href="#redis的级联复制" class="headerlink" title="redis的级联复制"></a>redis的级联复制</h4>之前搭建好的一主一从架构中，master和slave1节点无需修改，只需要修改slave2及slave3指向slave1作为master即可<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slave2,3</span></span><br><span class="line">redis-cli -a centos</span><br><span class="line">REPLICAOF 192.168.189.20 6379</span><br><span class="line">config <span class="built_in">set</span> masterauth centos</span><br><span class="line"><span class="comment"># slave1查看状态 info replication</span></span><br></pre></td></tr></table></figure>
<h4 id="主从复制优化"><a href="#主从复制优化" class="headerlink" title="主从复制优化"></a>主从复制优化</h4></li>
<li>主从同步完整过程</li>
</ul>
<ol>
<li>从服务器连接主服务器，发送PSYNC命令</li>
<li>主服务器接收到PSYNC命令后，开始执行BGSAVE命令生成RDB快照文件并使用缓冲区记录此后执行的所有写命令</li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送RDB快照文件，并在发送期间继续记录被执行的写命令</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照至内存</li>
<li>主服务器快照发送完毕后,开始向从服务器发送缓冲区中的写命令</li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令</li>
<li>后期同步会先发送自己slave_repl_offset位置，只同步新增加的数据，不再全量同步<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync no <span class="comment"># 是否使用无盘同步RDB文件，默认为no，no为不使用无盘，需要将RDB文件保存到磁盘后再发送给slave，yes为支持无盘，支持无盘就是RDB文件不需要保存至本地磁盘，而且直接通过socket文件发送给slave</span></span><br><span class="line">repl-diskless-sync-delay 5 <span class="comment">#diskless时复制的服务器等待的延迟时间</span></span><br><span class="line">repl-ping-slave-period 10 <span class="comment">#slave端向server端发送ping的时间间隔，默认为10秒</span></span><br><span class="line">repl-timeout 60 <span class="comment">#设置主从ping连接超时时间,超过此值无法连接,master_link_status显示为down,并记录错误日志</span></span><br><span class="line">repl-disable-tcp-nodelay no <span class="comment">#是否启用TCP_NODELAY，如设置成yes，则redis会合并小的TCP包从而节省带宽， 但会增加同步延迟（40ms），造成master与slave数据不一致，假如设置成no，则redismaster会立即发送同步数据，没有延迟，yes关注性能，no关注redis服务中的数据一致性</span></span><br><span class="line">repl-backlog-size 1mb <span class="comment">#master的写入数据缓冲区，用于记录自上一次同步后到下一次同步过程中间的写入命令，计算公式：repl-backlog-size = 允许从节点最大中断时长 * 主实例offset每秒写入量，比如master每秒最大写入64mb，最大允许60秒，那么就要设置为64mb*60秒=3840MB(3.8G),建议此值是设置的足够大</span></span><br><span class="line">repl-backlog-ttl 3600 <span class="comment">#如果一段时间后没有slave连接到master，则backlog size的内存将会被释放。如果值为0则表示永远不释放这部份内存。</span></span><br><span class="line">slave-priority 100 <span class="comment">#slave端的优先级设置，值是一个整数，数字越小表示优先级越高。当master故障时将会按照优先级来选择slave端进行恢复，如果值设置为0，则表示该slave永远不会被选择。</span></span><br><span class="line">min-replicas-to-write 1 <span class="comment">#设置一个master的可用slave不能少于多少个，否则master无法执行写</span></span><br><span class="line">min-slaves-max-lag 20 <span class="comment">#设置至少有上面数量的slave延迟时间都大于多少秒时，master不接收写操作(拒绝写入)</span></span><br></pre></td></tr></table></figure>
<h5 id="Redis主从复制分为全量同步和增量同步"><a href="#Redis主从复制分为全量同步和增量同步" class="headerlink" title="Redis主从复制分为全量同步和增量同步"></a>Redis主从复制分为全量同步和增量同步</h5></li>
</ol>
<ul>
<li>全量复制过程<br><strong>首次同步是全量同步，这时Slave需要将Master上的所有数据都复制一份。</strong>，主从同步可以让从服务器从主服务器同步数据，而且从服务器还可再有其它的从服务器，即另外一台redis服务器可以从一台从服务器进行数据同步，redis 的主从同步是非阻塞的，master收到从服务器的psync(2.8版本之前是SYNC)命令,会fork一个子进程在后台执行bgsave命令，并将新写入的数据写入到一个缓冲区中，bgsave执行完成之后,将生成的RDB文件发送给slave，然后master再将缓冲区的内容以redis协议格式再全部发送给slave，slave 先删除旧数据,slave将收到后的RDB文件载入自己的内存，再加载所有收到缓冲区的内容 从而这样一次完整的数据同步。<br><img src="/image/redis/14.jpg" alt="全量复制"></li>
<li>增量复制过程<br>全量同步之后再次需要同步时,从服务器只要发送当前的offset位置(等同于MySQL的binlog的位置)给主服务器，然后主服务器根据相应的位置将之后的数据(包括写在缓冲区的积压数据)发送给从服务器,其再次保存到其内存即可。<br><img src="/image/redis/15.jpg" alt="增量复制"><h5 id="复制缓冲区-环形队列-配置参数"><a href="#复制缓冲区-环形队列-配置参数" class="headerlink" title="复制缓冲区(环形队列)配置参数"></a>复制缓冲区(环形队列)配置参数</h5><img src="/image/redis/16.jpg" alt="环形队列"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制缓冲区大小，建议要设置足够大</span></span><br><span class="line">rep-backlog-size 1mb</span><br><span class="line"><span class="comment">#Redis同时也提供了当没有slave需要同步的时候，多久可以释放环形队列</span></span><br><span class="line">repl-backlog-ttl 3600</span><br></pre></td></tr></table></figure>
<h5 id="避免全量复制"><a href="#避免全量复制" class="headerlink" title="避免全量复制"></a>避免全量复制</h5>第一次全量复制不可避免,后续的全量复制可以利用小主节点(内存小),业务低峰时进行全量<br>节点运行 run-id 不匹配:主节点重启会导致RUNID变化,可能会触发全量复制,可以利用故障转<br>移，例如哨兵或集群,而从节点重新启动,不会导致全量复制<br><strong>复制积压缓冲区不足: 当主节点生成的新数据大于缓冲区大小,从节点恢复和主节点连接后,会<br>导致全量复制.解决方法将repl-backlog-size调大</strong><h5 id="单节点复制风暴"><a href="#单节点复制风暴" class="headerlink" title="单节点复制风暴"></a>单节点复制风暴</h5>尽量使用次级复联<br><img src="/image/redis/17.jpg" alt="单节点复制风暴"><h5 id="单机器复制风暴"><a href="#单机器复制风暴" class="headerlink" title="单机器复制风暴"></a>单机器复制风暴</h5>主节点分散多机器<br><img src="/image/redis/18.jpg" alt="单机器复制风暴"><h3 id="redis-哨兵-Sentinel"><a href="#redis-哨兵-Sentinel" class="headerlink" title="redis 哨兵(Sentinel)"></a>redis 哨兵(Sentinel)</h3>生产环境建议使用Redis的2.8版本的以后版本<br>哨兵(Sentinel) 是一个分布式系统，可以在一个架构中运行多个哨兵(sentinel) 进程，这些进程使用流言协议(gossip protocols)来接收关于Master主服务器是否下线的信息，并使用投票协议(AgreementProtocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><img src="/image/redis/19.jpg" alt="Redis Sentinel架构"><br><strong>主从架构无法实现master和slave角色的自动切换</strong>，即当master出现redis服务异常、主机断电、磁盘损坏等问题导致master无法使用，而redis主从复制无法实现自动的故障转移(将slave 自动提升为新master)，需要手动修改环境配置,才能切换到slave redis服务器，另外也无法横向扩展Redis服务的并行写入性能，当单台Redis服务器性能无法满足业务写入需求的时候,也需要解决以上的两个核心问题</li>
</ul>
<ol>
<li>master和slave角色的无缝切换，让业务无感知从而不影响业务使用</li>
<li>可横向动态扩展Redis服务器，从而实现多台服务器并行写入以实现更高并发的目的。</li>
</ol>
<ul>
<li>Redis 集群实现方式<br>客户端分片: 由应用决定将不同的KEY发送到不同的Redis服务器<br>代理分片: 由代理决定将不同的KEY发送到不同的Redis服务器<br>Redis Cluster<h4 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h4></li>
<li>每10秒每个sentinel对master和slave执行info<br>发现slave节点<br>确认主从关系</li>
<li>每2秒每个sentinel通过master节点的channel交换信(pub&#x2F;sub)<br>通过sentinel_hello频道交互<br>交互对节点的“看法”和自身信息</li>
<li>每1秒每个sentinel对其他sentinel和redis执行ping<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><strong>master的配置文件中masterauth和slave都必须相同</strong></li>
<li>在所有主从节点执行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /apps/redis/etc/redis.conf</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">masterauth centos</span><br><span class="line">requirepass centos</span><br><span class="line">*********************************************************</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;net.core.somaxconn = 1024\nvm.overcommit_memory = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&quot;</span> &gt;&gt; /etc/rc.d/rc.local</span><br><span class="line"><span class="built_in">chmod</span> +x /etc/rc.d/rc.local</span><br><span class="line">systemctl restart redis</span><br></pre></td></tr></table></figure></li>
<li>设置主从复制，所有节点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;replicaof 192.168.189.10 6379&quot;</span> &gt;&gt; /apps/redis/etc/redis.conf</span><br><span class="line">systemctl restart redis</span><br></pre></td></tr></table></figure></li>
<li>编辑哨兵的配置文件<br>Sentinel实际上是一个特殊的redis服务器,有些redis指令支持,但很多指令并不支持.默认监听<br>在26379&#x2F;tcp端口<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译安装在源码目录有sentinel.conf，复制到安装目录即可</span></span><br><span class="line"><span class="built_in">cp</span> redis-5.0.9/sentinel.conf /apps/redis/etc/</span><br><span class="line">grep -Ev <span class="string">&quot;^(#|$)&quot;</span> /apps/redis/etc/sentinel.conf <span class="comment"># 去注释</span></span><br><span class="line"><span class="comment">#############################################################</span></span><br><span class="line">port 26379</span><br><span class="line">daemonize no</span><br><span class="line">pidfile /var/run/redis-sentinel.pid</span><br><span class="line">logfile <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">dir</span> /tmp <span class="comment">#工作目录</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="comment">#指定当前mymaster集群中master服务器的地址和端口</span></span><br><span class="line"><span class="comment">#2为法定人数限制(quorum)，即有几个sentinel认为master down了就进行故障转移，一般此值是所有sentinel节点(一般总数是&gt;=3的 奇数,如:3,5,7等)的一半以上的整数值，比如，总数是3，即3/2=1.5，取整为2,是master的ODOWN客观下线的依据</span></span><br><span class="line">sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line"><span class="comment">#mymaster集群中master的密码，注意此行要在上面行的下面</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="comment">#(SDOWN)判断mymaster集群中所有节点的主观下线的时间，单位：毫秒，建议30000</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment">#发生故障转移后，同时向新master同步数据的slave数量，数字越小总同步时间越长，但可以减轻新master的负载压力</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"><span class="comment">#所有slaves指向新的master所需的超时时间，单位：毫秒</span></span><br><span class="line">sentinel deny-scripts-reconfig <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#禁止修改脚本</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># 主从服务器的配置</span></span><br><span class="line">port 26379</span><br><span class="line">daemonize no</span><br><span class="line">pidfile /apps/redis/run/redis-sentinel.pid</span><br><span class="line">logfile <span class="string">&quot;/apps/redis/log/sentinel.log&quot;</span></span><br><span class="line"><span class="built_in">dir</span> /tmp</span><br><span class="line">sentinel monitor mymaster 192.168.189.10 6379 2</span><br><span class="line">sentinel auth-pass mymaster centos</span><br><span class="line">sentinel down-after-milliseconds mymaster 3000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel deny-scripts-reconfig <span class="built_in">yes</span></span><br><span class="line"><span class="built_in">chown</span> redis.redis /apps/redis/etc/sentinel.conf</span><br></pre></td></tr></table></figure>
<h4 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三台哨兵服务器都要启动</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /lib/systemd/system/redis-sentinel.service</span></span><br><span class="line"><span class="string">    [Unit]</span></span><br><span class="line"><span class="string">    Description=Redis Sentinel</span></span><br><span class="line"><span class="string">    After=network.target</span></span><br><span class="line"><span class="string">    After=network-online.target</span></span><br><span class="line"><span class="string">    Wants=network-online.target</span></span><br><span class="line"><span class="string">    [Service]</span></span><br><span class="line"><span class="string">    ExecStart=/apps/redis/bin/redis-sentinel/apps/redis/etc/sentinel.conf --</span></span><br><span class="line"><span class="string">    supervised systemd</span></span><br><span class="line"><span class="string">    ExecStop=/usr/libexec/redis-shutdown redis-sentinel</span></span><br><span class="line"><span class="string">    Type=notify</span></span><br><span class="line"><span class="string">    User=redis</span></span><br><span class="line"><span class="string">    Group=redis</span></span><br><span class="line"><span class="string">    RuntimeDirectory=redis</span></span><br><span class="line"><span class="string">    RuntimeDirectoryMode=0755</span></span><br><span class="line"><span class="string">    [Install]</span></span><br><span class="line"><span class="string">    WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 确保每个哨兵主机myid不同</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now redis-sentinel</span><br><span class="line">grep myid /apps/redis/etc/sentinel.conf</span><br><span class="line"><span class="comment"># 验证端口</span></span><br><span class="line">ss -tnl <span class="comment"># 26379</span></span><br></pre></td></tr></table></figure>
<h4 id="测试故障转移"><a href="#测试故障转移" class="headerlink" title="测试故障转移"></a>测试故障转移</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master</span></span><br><span class="line">yum install psmisc -y &amp;&amp; killall redis-server</span><br><span class="line"><span class="comment"># 故障转移后的redis配置文件会被自动修改</span></span><br><span class="line">grep <span class="string">&quot;^replicaof&quot;</span> /apps/redis/etc/redis.conf</span><br><span class="line"><span class="comment"># sentinel monitor IP 同样也会被修改</span></span><br><span class="line">grep monitor /apps/redis/etc/sentinel.conf</span><br></pre></td></tr></table></figure>
<h4 id="恢复故障"><a href="#恢复故障" class="headerlink" title="恢复故障"></a>恢复故障</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master</span></span><br><span class="line">systemctl start redis</span><br><span class="line">grep <span class="string">&quot;^replicaof&quot;</span> /apps/redis/etc/redis.conf</span><br><span class="line"><span class="comment"># replicaof 192.168.189.30 6379</span></span><br></pre></td></tr></table></figure></li>
<li>手动让主节点下线<br><strong>指定优先级,值越小sentinel会优先将之选为新的master,默为值为100</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /apps/redis/etc/redis.conf</span><br><span class="line"><span class="comment"># replica-priority 10</span></span><br><span class="line">systemctl restart redis</span><br><span class="line">redis-cli -p 26379</span><br></pre></td></tr></table></figure>
<h4 id="python连接redis"><a href="#python连接redis" class="headerlink" title="python连接redis"></a>python连接redis</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release python3 python3-redis</span><br><span class="line">vim sentinel_test.py</span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> redis.sentinel <span class="keyword">import</span> Sentinel</span><br><span class="line"><span class="comment">#连接哨兵服务器(主机名也可以用域名)</span></span><br><span class="line">sentinel = Sentinel([(<span class="string">&#x27;192.168.189.10&#x27;</span>, <span class="number">26379</span>),(<span class="string">&#x27;192.168.189.20&#x27;</span>, <span class="number">26379</span>),(<span class="string">&#x27;192.168.189.30&#x27;</span>, <span class="number">26379</span>)],socket_timeout=<span class="number">0.5</span>)</span><br><span class="line">redis_auth_pass = <span class="string">&#x27;centos&#x27;</span></span><br><span class="line"><span class="comment">#mymaster 是配置哨兵模式的redis集群名称，此为默认值,实际名称按照个人部署案例来填写</span></span><br><span class="line"><span class="comment">#获取主服务器地址</span></span><br><span class="line">master = sentinel.discover_master(<span class="string">&#x27;mymaster&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(master)</span><br><span class="line"><span class="comment">#获取从服务器地址</span></span><br><span class="line">slave = sentinel.discover_slaves(<span class="string">&#x27;mymaster&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(slave)</span><br><span class="line"><span class="comment">#获取主服务器连接进行写入</span></span><br><span class="line">master = sentinel.master_for(<span class="string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="number">0.5</span>,password=redis_auth_pass, db=<span class="number">0</span>)</span><br><span class="line">w_ret = master.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="comment">#获取从服务器进行读取（默认是round-roubin）</span></span><br><span class="line">slave = sentinel.slave_for(<span class="string">&#x27;mymaster&#x27;</span>, socket_timeout=<span class="number">0.5</span>,password=redis_auth_pass, db=<span class="number">0</span>)</span><br><span class="line">r_ret = slave.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r_ret)</span><br><span class="line"><span class="comment"># python3 sentinel_test.py</span></span><br><span class="line">(<span class="string">&#x27;192.168.189.10&#x27;</span>, <span class="number">6379</span>)</span><br><span class="line">[(<span class="string">&#x27;192.168.189.20&#x27;</span>, <span class="number">6379</span>), (<span class="string">&#x27;192.168.189.30&#x27;</span>, <span class="number">6379</span>)]</span><br><span class="line"><span class="string">b&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3>哨兵sentinel机制中，可以解决redis高可用问题，即当master故障后可以自动将slave提升为<br>master，从而可以保证redis服务的正常使用，<strong>但是无法解决redis单机写入的瓶颈问题，即单机redis写入性能受限于单机的内存大小、并发数量、网卡速率等因素。</strong><br>redis 3.0版本之后推出了无中心架构的redis cluster机制，在无中心的redis集群当中，其每个节点保存当前节点数据和整个集群状态,每个节点都和其他所有节点连接</li>
<li>Redis cluster 基本架构<br>节点A覆盖：0-5460<br>节点B覆盖：5461-10922<br>节点C覆盖：10923-16383<br><img src="/image/redis/20.jpg" alt="基本架构"></li>
<li>Redis cluster 主从架构<br>对每个master 节点都实现主从复制,从而实现 redis 高可用性<br><img src="/image/redis/21.jpg" alt="主从架构"><h4 id="原生命令手动部署redis-cluster"><a href="#原生命令手动部署redis-cluster" class="headerlink" title="原生命令手动部署redis cluster"></a>原生命令手动部署redis cluster</h4>官方文档：<a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial</a><br><strong>6台服务器，分别是三组master&#x2F;slave，适用于生产环境</strong></li>
<li>所有节点安装redis并启动cluster功能，防火墙放行对应的端口号<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=1-65535/tcp --permanent</span><br><span class="line">firewall-cmd --add-port=1-65535/udp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">hostnamectl set-hostname master1</span><br></pre></td></tr></table></figure></li>
<li>所有节点启用redis集群支持<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cluster-enabled yes&quot;</span> &gt;&gt; /apps/redis/etc/redis.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;masterauth centos&quot;</span> &gt;&gt; /apps/redis/etc/redis.conf</span><br><span class="line"><span class="comment"># vim /apps/redis/etc/redis.conf</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line">masterauth centos</span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line">systemctl restart redis</span><br></pre></td></tr></table></figure></li>
<li>master1执行 meet 操作实现相互通信<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.189.10 -a centos --no-auth-warning cluster meet 192.168.189.11 6379</span><br><span class="line">redis-cli -h 192.168.189.10 -a centos --no-auth-warning cluster meet 192.168.189.20 6379</span><br><span class="line">redis-cli -h 192.168.189.10 -a centos --no-auth-warning cluster meet 192.168.189.21 6379</span><br><span class="line">redis-cli -h 192.168.189.10 -a centos --no-auth-warning cluster meet 192.168.189.30 6379</span><br><span class="line">redis-cli -h 192.168.189.10 -a centos --no-auth-warning cluster meet 192.168.189.31 6379</span><br></pre></td></tr></table></figure></li>
<li>每个master 节点指派槽位范围<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim addslots.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">HOST=<span class="variable">$1</span></span><br><span class="line">PORT=<span class="variable">$2</span></span><br><span class="line">START=<span class="variable">$3</span></span><br><span class="line">END=<span class="variable">$4</span></span><br><span class="line">PASS=centos</span><br><span class="line"><span class="keyword">for</span> slot <span class="keyword">in</span> `<span class="built_in">seq</span> <span class="variable">$&#123;START&#125;</span> <span class="variable">$&#123;END&#125;</span>`;<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;slot: <span class="variable">$&#123;slot&#125;</span>&quot;</span></span><br><span class="line">	redis-cli -h <span class="variable">$&#123;HOST&#125;</span> -p <span class="variable">$&#123;PORT&#125;</span> -a <span class="variable">$&#123;PASS&#125;</span> --no-auth-warning cluster addslots <span class="variable">$&#123;slot&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">bash addslots.sh 192.168.189.10 6379 0 5461</span><br><span class="line">bash addslots.sh 192.168.189.20 6379 5462 10922</span><br><span class="line">bash addslots.sh 192.168.189.30 6379 10923 16383</span><br></pre></td></tr></table></figure></li>
<li>指定各个节点的主从关系<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.175.10 -a centos --no-auth-warning cluster nodes</span><br><span class="line"><span class="comment"># 通过上面的cluster nodes 查看master的ID信息，执行下面操作，将对应的slave 指定相应的master节点，实现三对主从节点</span></span><br><span class="line">redis-cli -h 192.168.189.11 -a centos --no-auth-warning cluster replicate 48000fa51e653b3dbf3f70829fc9142c40195ff6</span><br><span class="line">redis-cli -h 192.168.189.21 -a centos --no-auth-warning cluster replicate 3ccb32a3e79572a16a1aa3e8188fff07121b1d1e</span><br><span class="line">redis-cli -h 192.168.189.31 -a centos --no-auth-warning cluster replicate fae9fe337678873ec0f3e0a44c39bd8064c85fb0</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://xczf.shop">betty bear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xczf.shop/2021/02/15/Redis/">http://xczf.shop/2021/02/15/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xczf.shop" target="_blank">betty bear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="/image/12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/01/Docker/"><img class="prev-cover" src="/image/13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/05/%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86-FTP-NFS/"><img class="next-cover" src="/image/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ssh、FTP、NFS</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/01/MongoDB/" title="MongoDB"><img class="cover" src="/image/19.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">MongoDB</div></div></a></div><div><a href="/2022/08/01/MySql/" title="MySql"><img class="cover" src="/image/20.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-01</div><div class="title">MySql</div></div></a></div><div><a href="/2023/09/01/memcache/" title="memcache"><img class="cover" src="/image/27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-01</div><div class="title">memcache</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">betty bear</div><div class="author-info__description">最在意的，或许得不到了</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/cate%EF%BC%9Agories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ccmmdd"><i class="fab fa-github"></i><span>不要点我呀！</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ccmmdd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3025346417@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">你也不想这件事被发现吧！~~~///(^v^)\\\~~~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.</span> <span class="toc-text">硬件缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.</span> <span class="toc-text">系统缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#buffer-%E4%B8%8E-cache"><span class="toc-number">1.2.1.</span> <span class="toc-text">buffer 与 cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.</span> <span class="toc-text">用户层缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS-%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">DNS 缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">浏览器缓存过期机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie-%E5%92%8C-session"><span class="toc-number">1.3.3.</span> <span class="toc-text">cookie 和 session</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.</span> <span class="toc-text">CDN缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#302%E5%AE%9E%E7%8E%B0%E8%BD%AC%E5%8F%91%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91%E8%87%B3%E6%9C%80%E4%BC%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4"><span class="toc-number">1.4.1.</span> <span class="toc-text">302实现转发请求重定向至最优服务器集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CDN%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">CDN流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E7%BC%93%E5%AD%98"><span class="toc-number">1.5.</span> <span class="toc-text">应用层缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%82%E7%BC%93%E5%AD%98"><span class="toc-number">1.6.</span> <span class="toc-text">数据层缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis"><span class="toc-number">2.</span> <span class="toc-text">redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%83%A8%E7%BD%B2"><span class="toc-number">2.1.</span> <span class="toc-text">Redis部署</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#yum%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.1.</span> <span class="toc-text">yum安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.2.</span> <span class="toc-text">编译安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">2.1.3.</span> <span class="toc-text">命令软链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%8F%B0%E5%90%AF%E5%8A%A8"><span class="toc-number">2.1.4.</span> <span class="toc-text">前台启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%A4%9A%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.5.</span> <span class="toc-text">启动多实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%89%E4%B8%AA%E5%91%8A%E8%AD%A6"><span class="toc-number">2.1.6.</span> <span class="toc-text">解决启动时三个告警</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tcp-backlog"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">tcp-backlog</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vm-overcommit-memory"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">vm.overcommit_memory</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transparent-huge-pages"><span class="toc-number">2.1.6.3.</span> <span class="toc-text">transparent huge pages</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#systemctl%E7%AE%A1%E7%90%86redis"><span class="toc-number">2.1.7.</span> <span class="toc-text">systemctl管理redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95"><span class="toc-number">2.1.8.</span> <span class="toc-text">设置密码登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.1.9.</span> <span class="toc-text">程序连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shell-%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.9.1.</span> <span class="toc-text">shell 连接方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python-%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.9.2.</span> <span class="toc-text">python 连接方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">RDB 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BF%AB%E7%85%A7"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">实现快照</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">重写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">AOF 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99-1"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">重写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">Redis 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#INFO-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9redis%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.1.</span> <span class="toc-text">INFO 显示当前节点redis运行状态信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SELECT-%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.3.2.</span> <span class="toc-text">SELECT 切换数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KEYS-%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%BA%93%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89key"><span class="toc-number">2.3.3.</span> <span class="toc-text">KEYS 查看当前库下的所有key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGSAVE-%E6%89%8B%E5%8A%A8%E5%9C%A8%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8CRDB%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.4.</span> <span class="toc-text">BGSAVE 手动在后台执行RDB持久化操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DBSIZE-%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E5%BA%93%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89key-%E6%95%B0%E9%87%8F"><span class="toc-number">2.3.5.</span> <span class="toc-text">DBSIZE 返回当前库下的所有key 数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FLUSHDB-%E5%BC%BA%E5%88%B6%E6%B8%85%E7%A9%BA%E5%BD%93%E5%89%8D%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89key-%E6%85%8E%E7%94%A8%EF%BC%81"><span class="toc-number">2.3.6.</span> <span class="toc-text">FLUSHDB 强制清空当前库中的所有key 慎用！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FLUSHALL-%E5%BC%BA%E5%88%B6%E6%B8%85%E7%A9%BA%E5%BD%93%E5%89%8Dredis%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE-%E6%85%8E%E7%94%A8%EF%BC%81"><span class="toc-number">2.3.7.</span> <span class="toc-text">FLUSHALL 强制清空当前redis服务器所有数据库中的所有数据 慎用！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHUTDOWN-%E5%81%9C%E6%AD%A2%E6%89%80%E6%9C%89%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.3.8.</span> <span class="toc-text">SHUTDOWN 停止所有客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">redis 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-string"><span class="toc-number">2.4.1.</span> <span class="toc-text">字符串 string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8-list"><span class="toc-number">2.4.2.</span> <span class="toc-text">列表 list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88-set"><span class="toc-number">2.4.3.</span> <span class="toc-text">集合 set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-sorted-set"><span class="toc-number">2.4.4.</span> <span class="toc-text">有序集合 sorted set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C-hash"><span class="toc-number">2.4.5.</span> <span class="toc-text">哈希 hash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.5.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">生产者消费者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">发布者订阅模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">2.6.</span> <span class="toc-text">redis主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">2.6.1.</span> <span class="toc-text">实现主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">命令行方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9slave%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">修改slave节点配置文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">2.6.2.</span> <span class="toc-text">主从复制故障恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E7%9A%84%E7%BA%A7%E8%81%94%E5%A4%8D%E5%88%B6"><span class="toc-number">2.6.3.</span> <span class="toc-text">redis的级联复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BC%98%E5%8C%96"><span class="toc-number">2.6.4.</span> <span class="toc-text">主从复制优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%88%86%E4%B8%BA%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">Redis主从复制分为全量同步和增量同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2%E5%8C%BA-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">复制缓冲区(环形队列)配置参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">2.6.4.3.</span> <span class="toc-text">避免全量复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E8%8A%82%E7%82%B9%E5%A4%8D%E5%88%B6%E9%A3%8E%E6%9A%B4"><span class="toc-number">2.6.4.4.</span> <span class="toc-text">单节点复制风暴</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%99%A8%E5%A4%8D%E5%88%B6%E9%A3%8E%E6%9A%B4"><span class="toc-number">2.6.4.5.</span> <span class="toc-text">单机器复制风暴</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E5%93%A8%E5%85%B5-Sentinel"><span class="toc-number">2.7.</span> <span class="toc-text">redis 哨兵(Sentinel)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">2.7.1.</span> <span class="toc-text">集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.7.2.</span> <span class="toc-text">三个定时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2"><span class="toc-number">2.7.3.</span> <span class="toc-text">部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%93%A8%E5%85%B5"><span class="toc-number">2.7.4.</span> <span class="toc-text">启动哨兵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">2.7.5.</span> <span class="toc-text">测试故障转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E6%95%85%E9%9A%9C"><span class="toc-number">2.7.6.</span> <span class="toc-text">恢复故障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E8%BF%9E%E6%8E%A5redis"><span class="toc-number">2.7.7.</span> <span class="toc-text">python连接redis</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Cluster"><span class="toc-number">2.8.</span> <span class="toc-text">Redis Cluster</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%91%BD%E4%BB%A4%E6%89%8B%E5%8A%A8%E9%83%A8%E7%BD%B2redis-cluster"><span class="toc-number">2.8.1.</span> <span class="toc-text">原生命令手动部署redis cluster</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/01/DevOps/" title="devops"><img src="/image/16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="devops"/></a><div class="content"><a class="title" href="/2023/10/01/DevOps/" title="devops">devops</a><time datetime="2023-10-01T11:00:41.000Z" title="发表于 2023-10-01 19:00:41">2023-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/01/memcache/" title="memcache"><img src="/image/27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="memcache"/></a><div class="content"><a class="title" href="/2023/09/01/memcache/" title="memcache">memcache</a><time datetime="2023-09-01T11:00:41.000Z" title="发表于 2023-09-01 19:00:41">2023-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/01/python-PyQt/" title="Python-PyQt"><img src="/image/33.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python-PyQt"/></a><div class="content"><a class="title" href="/2023/08/01/python-PyQt/" title="Python-PyQt">Python-PyQt</a><time datetime="2023-08-01T11:00:41.000Z" title="发表于 2023-08-01 19:00:41">2023-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/15/OpenStack/" title="Openstack"><img src="/image/25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Openstack"/></a><div class="content"><a class="title" href="/2023/07/15/OpenStack/" title="Openstack">Openstack</a><time datetime="2023-07-15T11:00:41.000Z" title="发表于 2023-07-15 19:00:41">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/01/python-flask/" title="Python-Flask"><img src="/image/35.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python-Flask"/></a><div class="content"><a class="title" href="/2023/05/01/python-flask/" title="Python-Flask">Python-Flask</a><time datetime="2023-05-01T11:00:41.000Z" title="发表于 2023-05-01 19:00:41">2023-05-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/image/12.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By betty bear</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">啊，对对对!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://xczf.shop/2021/02/15/Redis/'
    this.page.identifier = '2021/02/15/Redis/'
    this.page.title = 'Redis'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer src="/live2d-widget/autoload.js"></script><div class="aplayer no-destroy" data-id="8828254214" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>