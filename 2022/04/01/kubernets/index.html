<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Kubernetes | betty bear</title><meta name="keywords" content="linux"><meta name="author" content="betty bear,3025346417@qq.com"><meta name="copyright" content="betty bear"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="KubernetesKubernetes是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。kubernetes拥有一个庞大且快速增长的生态系统。 为什么使用kubernetes 自动装箱建构于容器之上，基于资源依赖及其他约束自动完成容器部署且不影响其可用性，并通过调度机制混合关键性应用和非关键型应用的工作负载于同一节点以提升资源利用率 自我修复（自愈）支持">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes">
<meta property="og:url" content="http://xczf.shop/2022/04/01/kubernets/index.html">
<meta property="og:site_name" content="betty bear">
<meta property="og:description" content="KubernetesKubernetes是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。kubernetes拥有一个庞大且快速增长的生态系统。 为什么使用kubernetes 自动装箱建构于容器之上，基于资源依赖及其他约束自动完成容器部署且不影响其可用性，并通过调度机制混合关键性应用和非关键型应用的工作负载于同一节点以提升资源利用率 自我修复（自愈）支持">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xczf.shop/image/36.jpg">
<meta property="article:published_time" content="2022-04-01T11:00:41.000Z">
<meta property="article:modified_time" content="2024-02-18T08:52:32.078Z">
<meta property="article:author" content="betty bear">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xczf.shop/image/36.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://xczf.shop/2022/04/01/kubernets/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: betty bear","link":"链接: ","source":"来源: betty bear","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-18 16:52:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="betty bear" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/cate%EF%BC%9Agories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 便签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/36.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">betty bear</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 便签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kubernetes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-01T11:00:41.000Z" title="发表于 2022-04-01 19:00:41">2022-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-18T08:52:32.078Z" title="更新于 2024-02-18 16:52:32">2024-02-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/cate%EF%BC%9Agories/linux/">linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kubernetes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Kubernetes是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。kubernetes拥有一个庞大且快速增长的生态系统。</p>
<h3 id="为什么使用kubernetes"><a href="#为什么使用kubernetes" class="headerlink" title="为什么使用kubernetes"></a>为什么使用kubernetes</h3><ul>
<li>自动装箱<br>建构于容器之上，基于资源依赖及其他约束自动完成容器部署且不影响其可用性，并通过调度机制混合<br>关键性应用和非关键型应用的工作负载于同一节点以提升资源利用率</li>
<li>自我修复（自愈）<br>支持容器故障后自动重启、节点故障后重新调度容器，以及其他可用节点、健康状态检查失败后关闭容器并重新创建等自我修复机制。</li>
<li>水平扩展<br>支持通过命令或UI手动水平扩展，以及基于cpu等资源负载率的自动水平扩展机制。</li>
<li>服务发现和负载均衡<br>Kubernets通过其附加组件KubeDNS（或CoreDNS）为系统内置了服务发现功能，它会为每个service配置DNS名称，并允许集群内的客户端直接使用此名称发出请求，而Service则通过iptables或ipvs内建了负载均衡机制。</li>
<li>自动发布和回滚<br>Kubernets支持灰度更新应用程序或其配置信息，它会监控更新过程中应用程序的健康状态，以确保它不会在同一时刻杀掉所有实例，而此过程中一旦有故障发生，就会立即自动执行回滚操作</li>
<li>密钥和配置管理<br>kubernetsd的configmap实现了配置数据与Docker镜像解耦，需要时，仅对配置做出变更而无须重新构建docker镜像，这为应用开发部署带来了很大的灵活性。此外，对于应用所依赖的一些敏感数据，如用户名和密码、令牌、密钥等信息，Kubernetes专门提供了secret对象为其解耦，既便利了应用的快速开发和交付，又提供一定程度上的安全保障。</li>
<li>存储编排<br>Kubernets支持pod对象按需自动挂载不同类型的存储系统，这包括节点本地存储、公有云服务商的云存储，以及网络存储系统<h3 id="Kubernets-组件"><a href="#Kubernets-组件" class="headerlink" title="Kubernets 组件"></a>Kubernets 组件</h3>一个kubernetes集群由一组被称作节点的机器组成。这些节点上运行Kubernetes所管理的容器化应用。集群具有至少一个工作节点。<br>工作节点托管作为应用负载的组件的Pod。控制平面管理集群中的工作节点和pod。为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。<br>Mater：集群中的一台服务器用作Master，负责管理整个集群。Master是集群的网关和中枢，负责诸如为用户和客户端暴露API、跟踪其他服务器的健康状态、以最优方式调度工作负载，以及编排其他组件之间的通信任务，它是用户或客户端与集群之间的核心联络点，并负载Kubernetes系统的大多数集中式管<br>控逻辑。单个master节点即可完成其所有的功能，但出于冗余及负载均衡等目的，生产环境中通常需要协同部署多个此类主机。<br>Node：Node是Kubernetes集群的工作节点，负责接收来自master的工作指令相应地创建或销毁Pod对象，以及调整网络规则以合理地路由和转发流量等。<br><img src="/image/docker/4.jpg"><h4 id="控制平面组件"><a href="#控制平面组件" class="headerlink" title="控制平面组件"></a>控制平面组件</h4>控制平面组件可以在集群中的任何节点上运行。然后，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件，并且不会在此计算机上运行用户容器。</li>
<li>kube-apiserver<br>Api server负责输出restful风格的kubernetes API，它是发往集群的所有REST操作命令的接入点，并负责接收、校验并响应所有的REST请求，结果状态被持久存储于etcd中。<strong>api server是整个集群的网关。</strong></li>
<li>etcd<br>kubernetes集群的所有状态信息都需要持久存储于存储系统etcd中，不过，etcd是由CoreOS基于Raft协议开发的分布式键值存储，可用于服务发现、共享配置以及一致性保障（如数据库主节点选择、分布式锁等）。因此，etcd是独立的服务组件，并不隶属于Kubernetes集群自身。<br>etcd不仅能够提供键值数据存储，而且还为其提供了监听机制，用于监听和推送变更。Kubernetes集群系统中，etcd中的键值发生变化时会通知到api server。</li>
<li>kube-controller-manager<br>kubernetes中，集群级别的大多数功能都是由几个被称为控制器的进程执行实现的，这几个进程被集成于kube-controller-manager守护进程中。由控制器完成的功能主要包括生命周期功能和api业务逻辑。</li>
<li>kube-scheduler<br>Kubernetes是用于部署和管理大规模容器应用的平台。api server确认pod对象的创建请求之后，便需要由scheduler根据集群内各节点的可用资源状态，以及要运行的容器的资源需求做出调度决策。<h4 id="Node组件"><a href="#Node组件" class="headerlink" title="Node组件"></a>Node组件</h4></li>
<li>kubelet<br>kubelet是运行于工作节点上的守护进程，它从api server接收关于pod对象的配置信息并确保他们处于期望的状态，kubelet会在api server上注册当前的工作节点，定期向master汇报节点资源使用情况。</li>
<li>kubeproxy<br>每个工作节点都需要运行一个kube-proxy守护进程，它能够按需为service资源对象生成iptables或者ipvs规则，从而捕获当前service的流量并将其转发至正确的后端pod对象。<h3 id="kubernetes网络模型"><a href="#kubernetes网络模型" class="headerlink" title="kubernetes网络模型"></a>kubernetes网络模型</h3><img src="/image/docker/5.jpg"><br>各主机自身所属的网络，其地址配置于主机的网络接口，用于各主机之间的通信，例如master与各node之间的通信。此地址配置于kubernetes集群构建之前，它并不能由kubernetes管理，管理员需要于集群构建之前自行确定其地址配置及管理方式。<br>kubernetes集群上专用于pod资源对象的网络，它是一个虚拟网络，用于为各pod对象设定ip地址等网络参数，其地址配置于pod中容器的网络接口之上。pod网络需要借助kubenet插件或CNI插件实现，该插件可独立部署于kubernetes集群之外，亦可托管于kubernetes之上，它需要在构建kubernetes集群时由管理员进行定义，而后在创建Pod对象时由其自动完成各网络参数的动态配置。<br>用于service资源对象的网络，它也是一个虚拟网络，用于为kubernetes集群之中的service配置ip地址，但此地址不配置于任何主机或容器的网络接口上，而是通过Node之上的kube-proxy配置为iptables或ipvs规则，从而将发往此地址的所有流量调度至其后端的各pod对象之上。service网络在kubernetes集群创建时予以指定，而service的地址则在用户创建service时予以动态配置<h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 准备</span><br><span class="line">k8s-master1 192.168.189.130</span><br><span class="line">k8s-node1   192.168.189.140</span><br><span class="line">k8s-node2   192.168.189.141</span><br></pre></td></tr></table></figure></li>
<li>环境准备(所有机器)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config</span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br><span class="line"><span class="comment"># 修改主机名</span></span><br><span class="line">hostnamectl set-hostname k8s-master1</span><br><span class="line">hostnamectl set-hostname k8s-node1</span><br><span class="line">hostnamectl set-hostname k8s-node2</span><br><span class="line"><span class="comment"># 所有机器上添加主机名于ip对应关系</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.189.130 k8s-master1</span><br><span class="line">192.168.189.140 k8s-node1</span><br><span class="line">192.168.189.141 k8s-node2</span><br><span class="line"><span class="comment"># 所有机器上将桥接的ipv4流量传递到iptables的链</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li>
<li>所有节点安装docker(所有机器)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install wget.x86_64 -y</span><br><span class="line"><span class="built_in">rm</span> -rf /etc/yum.repos.d/*</span><br><span class="line">wget -O /etc/yum.repos.d/centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum install docker-ce-20.10.11 -y</span><br></pre></td></tr></table></figure></li>
<li>集群部署(所有机器)<br>镜像仓库：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/mirror/kubernetes?spm=a2c6h.13651102.0.0.3e221b11tmy01T">https://developer.aliyun.com/mirror/kubernetes?spm=a2c6h.13651102.0.0.3e221b11tmy01T</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">yum install kubelet-1.22.2 kubeadm-1.22.2 kubectl-1.22.2 -y</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure></li>
<li>修改docker配置并进行加速(所有机器)<br><a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [&quot;https://c8il3sds.mirror.aliyuncs.com&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br><span class="line">systemctl restart kubelet.service</span><br><span class="line">systemctl status kubelet.service</span><br></pre></td></tr></table></figure></li>
<li>部署master(master节点配置)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.189.130 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.22.2 \</span><br><span class="line">--control-plane-endpoint k8s-master1 \</span><br><span class="line">--service-cidr=172.16.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"><span class="comment"># # 遇到镜像下载问题可以单独下载，比如，</span></span><br><span class="line"><span class="comment"># docker pull registry.aliyuncs.com/google_containers/coredns:1.8.4</span></span><br><span class="line"><span class="comment"># docker tag registry.aliyuncs.com/google_containers/coredns:1.8.4 registry.aliyuncs.com/google_containers/coredns:v1.8.4</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line">kubectl get nodes <span class="comment"># 查看节点状态为notready</span></span><br></pre></td></tr></table></figure>
<img src="/image/docker/6.jpg" alt=" "></li>
<li>安装网络插件，官方文档：<a target="_blank" rel="noopener" href="https://github.com/flannel-io/flannel">https://github.com/flannel-io/flannel</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull quay.io/coreos/flannel:v0.14.0</span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure></li>
<li>node节点配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull quay.io/coreos/flannel:v0.14.0</span><br><span class="line">kubeadm <span class="built_in">join</span> k8s-master1:6443 --token 0vcjor.ul6w77a9j2gwu1sf --discovery-token-ca-cert-hash sha256:1fca4652d905e8b8716ac06b976fd6aea89b22512e84320a37ea2ddc62b8952f <span class="comment"># 替换为图片中部分</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<img src="/image/docker/7.jpg" alt=" "></li>
<li>TEST<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">kubectl get service <span class="comment"># 查看service</span></span><br></pre></td></tr></table></figure>
<h3 id="kubernetes资源管理"><a href="#kubernetes资源管理" class="headerlink" title="kubernetes资源管理"></a>kubernetes资源管理</h3><strong>kubernetes系统将一切事物都抽象为API资源</strong><h4 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h4></li>
<li>工作负载型资源<br><strong>Pod是工作负载型资源中的基础资源，它负责运行容器</strong>，并为其解决环境性的依赖。但pod可能会因为资源超限或节点故障等原因而终止，这些非正常终止的Pod资源需要被重建，不过这类工作将由工作负载型的控制器来完成，他们通常也称之为pod控制器。<br>ReplicaSet：用于确保每个pod副本在任意时刻均能满足目标数量，保证每个容器或容器组总是运行并且可访问。<br>Deployment：它用于为pod和ReplicaSet提供声明式更新，是建构在ReplicaSet之上的更为高级的控制器<br>StatefulSet：用于管理有状态的持久化应用，如database服务程序<br>DaemonSet：用于确保每个节点都运行了某pod的一个副本，新增的节点一样会被添加此类pod；在节点被移除时，此类pod会被回收<br>Job：用于管理运行完成后即可终止的应用</li>
<li>发现和负载均衡<br>Pod资源可能会因为任何意外故障而被重建，于是它需要固定的可被发现的方式。<strong>Pod资源仅在集群内可见，它的客户端也可能是集群内的其他pod资源，若要开放给外部网络中的用户访问，则需要事先将其暴露到集群外部，并要为同一种工作负载的访问流量进行负载均衡。</strong></li>
<li>配置与存储<br>Docker容器分层联合挂载的方式决定了不宜在容器内部存储需要持久化的数据，于是它通过引入挂载外部存储卷的方式来解决此类问题，而<strong>kubernetes则为此涉及了volume资源，它支持众多类型的存储设备或存储系统。</strong></li>
<li>集群级资源<br>kubernetes还存在一些集群级别的资源，用于定义集群自身配置信息的对象，他们仅仅应该由集群管理员进行操作。<br>Namespace：资源对象名称的作用范围，绝大多数对象都隶属于某个名称空间，默认时隶属于defalut<br>Node：Kubernetes集群的工作节点，其标识符在当前集群中必须是唯一的。<br>Role：名称空间级别的由规则组成的权限集合<br>ClusterRole、RoleBinding、ClusterRoleBinding……</li>
<li>元数据型资源<br>此类对象用于为集群内部的其他资源配置其行为或特性。<h4 id="对象资源格式"><a href="#对象资源格式" class="headerlink" title="对象资源格式"></a>对象资源格式</h4></li>
<li>资源配置清单<br>使用yaml格式的文件来创建符合我们预期期望的pod，这样的yaml文件我们一般称为资<br>源清单</li>
<li>语法<br>大小写敏感<br>使用缩进表示层级关系<br><strong>缩进不允许使用tab，只允许空格( 低版本限制 )</strong><br>缩进的空格数不重要，只要相同层级的元素左对齐即可<br>‘#’表示注释<br><strong>验证yaml是否书写正确</strong>：<a target="_blank" rel="noopener" href="https://oktools.net/json2yaml">https://oktools.net/json2yaml</a></li>
<li>格式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: group/apiversion <span class="comment"># 如果没有给定group名称，那么默认为coe，可以使用kubectl api-versions 获取当前k8s版本上所有的apiVersion版本信息(每个版本可能不同) kubectl api-resources可以查看到资源对应的api版本</span></span><br><span class="line">kind: <span class="comment">#资源类别</span></span><br><span class="line">metadata： <span class="comment">#资源元数据</span></span><br><span class="line">name</span><br><span class="line">namespace <span class="comment">#k8s自身的namespace</span></span><br><span class="line">lables</span><br><span class="line">annotations <span class="comment">#主要目的是方便用户阅读查找</span></span><br><span class="line">spec:<span class="comment"># 期望的状态（disired state）  kubectl explain pods.spec查询pod字段说明</span></span><br><span class="line">status：<span class="comment"># 当前状态，本字段有kubernetes自身维护，用户不能去定义</span></span><br></pre></td></tr></table></figure>
<h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes<br>kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。<br><strong>kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在 Pod 中，而kubernetes一般也不会直接管理Pod，而是通过 Pod控制器 来管理Pod的。</strong><br>Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了 Service 资源实现这个功能。<br>当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种存储系统。<br><img src="/image/docker/8.jpg" alt=" "><h5 id="资源管理方式"><a href="#资源管理方式" class="headerlink" title="资源管理方式"></a>资源管理方式</h5><h6 id="命令式对象管理：直接使用命令去操作kubernetes资源"><a href="#命令式对象管理：直接使用命令去操作kubernetes资源" class="headerlink" title="命令式对象管理：直接使用命令去操作kubernetes资源"></a>命令式对象管理：直接使用命令去操作kubernetes资源</h6>kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群进行容器化应用的安装部署。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl [<span class="built_in">command</span>] [<span class="built_in">type</span>] [name] [flags]</span><br><span class="line">comand：指定要对资源执行的操作，例如create、get、delete</span><br><span class="line"><span class="built_in">type</span>：指定资源类型，比如deployment、pod、service</span><br><span class="line">name：指定资源的名称，名称大小写敏感</span><br><span class="line">flags：指定额外的可选参数</span><br></pre></td></tr></table></figure>
<img src="/image/docker/10.jpg" alt=" "></li>
<li>资源类型  kubectl api-resources<br>kubernetes中所有的内容都抽象为资源<br><img src="/image/docker/9.jpg" alt=" "><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># namespace/pod的创建和删除</span></span><br><span class="line"><span class="comment"># 创建一个namespace</span></span><br><span class="line">kubectl create namespace dev</span><br><span class="line"><span class="comment"># 获取namespace</span></span><br><span class="line">kubectl get ns</span><br><span class="line"><span class="comment"># 在此namespace下创建并运行一个nginx的Pod</span></span><br><span class="line">kubectl run pod1 --image=nginx:latest -n dev</span><br><span class="line"><span class="comment"># 查看新创建的pod</span></span><br><span class="line">kubectl get pod -n dev</span><br><span class="line"><span class="comment"># 删除指定的pod</span></span><br><span class="line">kubectl delete pod pod1 -n dev</span><br><span class="line"><span class="comment"># 删除指定的namespace</span></span><br><span class="line">kubectl delete ns dev</span><br></pre></td></tr></table></figure>
<h6 id="命令式对象配置：通过命令配置和配置文件去操作kubernetes资源"><a href="#命令式对象配置：通过命令配置和配置文件去操作kubernetes资源" class="headerlink" title="命令式对象配置：通过命令配置和配置文件去操作kubernetes资源"></a>命令式对象配置：通过命令配置和配置文件去操作kubernetes资源</h6>命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个nginxpod.yam</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginxpod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-containers</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line"><span class="comment"># 执行create命令，创建资源</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">nginxpod.yaml</span></span><br><span class="line"><span class="comment"># 查看资源</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">get</span> <span class="string">-f</span> <span class="string">nginxpod.yaml</span></span><br><span class="line"><span class="comment"># 删除资源</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">nginxpod.yaml</span></span><br></pre></td></tr></table></figure>
<h6 id="声明式对象配置：通过apply命令和配置文件去操作kubernetes资源"><a href="#声明式对象配置：通过apply命令和配置文件去操作kubernetes资源" class="headerlink" title="声明式对象配置：通过apply命令和配置文件去操作kubernetes资源"></a>声明式对象配置：通过apply命令和配置文件去操作kubernetes资源</h6>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f nginxpod.yaml</span><br><span class="line"><span class="comment"># 使用apply操作资源：</span></span><br><span class="line"><span class="comment"># 如果资源不存在，就创建，相当于 kubectl create</span></span><br><span class="line"><span class="comment"># 如果资源已存在，就更新，相当于 kubectl patch</span></span><br></pre></td></tr></table></figure>
<h5 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h5>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现<strong>多套环境的资源隔离或者多租户的资源隔离。</strong><br>默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的”组”，以方便不同的组的资源进行隔离使用和管理。<br>可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。<br><img src="/image/docker/11.jpg" alt=" "><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有的ns</span></span><br><span class="line">kubectl get ns</span><br><span class="line"><span class="comment"># 查看指定的ns</span></span><br><span class="line">kubectl get ns default</span><br><span class="line"><span class="comment"># 指定输出格式 kubectl get ns ns名称 -o 格式参数</span></span><br><span class="line"><span class="comment"># kubernetes支持的格式有很多，比较常见的是wide、json、yaml</span></span><br><span class="line">kubectl get ns default -o yaml</span><br><span class="line"><span class="comment"># 查看ns详情 </span></span><br><span class="line">kubectl describe ns default</span><br><span class="line"><span class="comment"># ResourceQuota 针对namespace做的资源限制</span></span><br><span class="line"><span class="comment"># LimitRange针对namespace中的每个组件做的资源限制</span></span><br><span class="line"><span class="comment"># 创建namespace</span></span><br><span class="line">kubectl create ns dev</span><br><span class="line"><span class="comment"># 删除namespace</span></span><br><span class="line">kubectl delete ns dev</span><br></pre></td></tr></table></figure>
<h5 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h5>Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。<br>Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行</span></span><br><span class="line">kubectl get pod -n kube-system</span><br><span class="line"><span class="comment"># 创建并运行</span></span><br><span class="line"><span class="comment"># kubectl create deploy (pod控制器名称) [参数]</span></span><br><span class="line"><span class="comment"># --image 指定Pod的镜像</span></span><br><span class="line"><span class="comment"># --port 指定端口</span></span><br><span class="line"><span class="comment"># --namespace 指定namespace</span></span><br><span class="line">kubectl create deploy nginx --image=nginx --port=80 -n dev</span><br><span class="line"><span class="comment"># 查看Pod基本信息</span></span><br><span class="line">kubectl get pods -n dev</span><br><span class="line"><span class="comment"># 查看Pod的详细信息</span></span><br><span class="line">kubectl describe pod [NAME] -n dev</span><br><span class="line"><span class="comment"># 获取podIP</span></span><br><span class="line">kubectl get pods -n dev -o wide</span><br><span class="line"><span class="comment"># 删除指定Pod</span></span><br><span class="line">kubectl delete pod [NAME] -n dev</span><br><span class="line"><span class="comment"># 当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建，此时要想删除Pod，必须删除Pod控制器</span></span><br><span class="line"><span class="comment"># 删除PodPod控制器</span></span><br><span class="line">kubectl delete deploy nginx -n dev</span><br></pre></td></tr></table></figure>
<h5 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h5>作用就是在资源上添加标识，用来对它们进行区分和选择。<br>Label的特点：<br>一个Label会以key&#x2F;value键值对的形式附加到各种对象上，如Node、Pod、Service等等<br>一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源<br>Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为pod资源打标签</span></span><br><span class="line">kubectl label pod nginx version=1.0 -n dev</span><br><span class="line"><span class="comment"># 为pod资源更新标签</span></span><br><span class="line">kubectl label pod nginx version=2.0 -n dev --overwrite</span><br><span class="line"><span class="comment"># 查看标签</span></span><br><span class="line">kubectl get pod nginx-pod -n dev --show-labels</span><br><span class="line"><span class="comment"># 筛选标签</span></span><br><span class="line">kubectl get pod -n dev -l version=2.0 --show-labels</span><br><span class="line">kubectl get pod -n dev -l version!=2.0 --show-labels</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除标签</span></span><br><span class="line">kubectl label pod nginx version- -n dev pod/nginx-pod labeled</span><br></pre></td></tr></table></figure>
<h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><img src="/image/docker/12.jpg" alt=" "><br>利用Deployment创建一组Pod来提供具有高可用性的服务,每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：<br><strong>Pod IP 会随着Pod的重建产生变化<br>Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问</strong><br>kubernetes设计了Service来解决这个问题，Service可以看作是一组同类Pod对外的访问接口。借助Service，应用可以方便地实现服务发现和负载均衡。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建集群内部可访问的Service</span></span><br><span class="line"><span class="comment"># 暴露Service</span></span><br><span class="line">kubectl expose deploy nginx --name=svc-nginx1 --<span class="built_in">type</span>=ClusterIP --port=80 --target-port=80 -n dev</span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">kubectl get svc svc-nginx1 -n dev -o wide</span><br><span class="line"><span class="comment"># 产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的</span></span><br><span class="line"><span class="comment"># 创建集群外部也可访问的Service</span></span><br><span class="line"><span class="comment"># 上面创建的Service的type类型为ClusterIP，这个ip地址只用集群内部可访问</span></span><br><span class="line"><span class="comment"># 如果需要创建外部也可以访问的Service，需要修改type为NodePort</span></span><br><span class="line">kubectl expose deploy nginx --name=svc-nginx2 --<span class="built_in">type</span>=NodePort --port=80 --target-port=80 -n dev</span><br><span class="line"><span class="comment"># 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC）</span></span><br><span class="line">kubectl get svc svc-nginx2 -n dev -o wide</span><br><span class="line"><span class="comment"># 删除Service</span></span><br><span class="line">kubectl delete svc svc-nginx1 -n dev</span><br></pre></td></tr></table></figure>
<h3 id="容器与pod资源对象"><a href="#容器与pod资源对象" class="headerlink" title="容器与pod资源对象"></a>容器与pod资源对象</h3><h4 id="Pod资源清单"><a href="#Pod资源清单" class="headerlink" title="Pod资源清单"></a>Pod资源清单</h4>kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：<br>apiVersion版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions查询到<br>kind类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到<br>metadata 元数据，主要是资源标识和说明，常用的有name、namespace、labels<br>spec  描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述<br>status 状态信息，里面的内容不需要定义，由kubernetes自动生成<br>上面的属性中，<strong>spec是的重点</strong>，常见子属性:<br>containers 容器列表，用于定义容器的详细信息<br>nodeName 根据nodeName的值将pod调度到指定的Node节点上<br>nodeSelector根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上<br>hostNetwork是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络<br>volumes 存储卷，用于定义Pod上面挂在的存储信息<br>restartPolicy  重启策略，表示Pod在遇到故障的时候的处理策略<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl explain 资源类型 查看某种资源可以配置的一级属性</span></span><br><span class="line"><span class="comment"># kubectl explain 资源类型.属性 查看属性的子属性</span></span><br><span class="line">apiVersion: v1 <span class="comment">#必选，版本号，例如v1</span></span><br><span class="line">kind: Pod <span class="comment">#必选，资源类型，例如 Pod</span></span><br><span class="line">metadata: <span class="comment">#必选，元数据</span></span><br><span class="line">  name: string <span class="comment">#必选，Pod名称</span></span><br><span class="line">  namespace: string <span class="comment">#Pod所属的命名空间,默认为&quot;default&quot;</span></span><br><span class="line">  labels: <span class="comment">#自定义标签列表</span></span><br><span class="line">    - name: string</span><br><span class="line">spec: <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line">  containers: <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  - name: string <span class="comment">#必选，容器名称</span></span><br><span class="line">    image: string <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    imagePullPolicy: [ Always|Never|IfNotPresent ] <span class="comment">#获取镜像的策略</span></span><br><span class="line">    <span class="built_in">command</span>: [string] <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    args: [string] <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    workingDir: string <span class="comment">#容器的工作目录</span></span><br><span class="line">    volumeMounts: <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">      - name: string <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      mountPath: string <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      readOnly: boolean <span class="comment">#是否为只读模式</span></span><br><span class="line">    ports: <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">      - name: string <span class="comment">#端口的名称</span></span><br><span class="line">        containerPort: int <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">        hostPort: int <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">        protocol: string <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="built_in">env</span>: <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    - name: string <span class="comment">#环境变量名称</span></span><br><span class="line">      value: string <span class="comment">#环境变量的值</span></span><br><span class="line">    resources: <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      limits: <span class="comment">#资源限制的设置</span></span><br><span class="line">        cpu: string <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        memory: string <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line">        requests: <span class="comment">#资源请求的设置</span></span><br><span class="line">          cpu: string <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">          memory: string <span class="comment">#内存请求,容器启动的初始可用数量</span></span><br><span class="line">    lifecycle: <span class="comment">#生命周期钩子</span></span><br><span class="line">      postStart: <span class="comment">#容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span></span><br><span class="line">      preStop: <span class="comment">#容器终止前执行此钩子,无论结果如何,容器都会终止</span></span><br><span class="line">    livenessProbe: <span class="comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span></span><br><span class="line">      <span class="built_in">exec</span>: <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line">        <span class="built_in">command</span>: [string] <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line">      httpGet: <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">       tcpSocket: <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0 <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line">       timeoutSeconds: 0 <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line">       periodSeconds: 0 <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged: <span class="literal">false</span></span><br><span class="line">  restartPolicy: [Always | Never | OnFailure] <span class="comment">#Pod的重启策略</span></span><br><span class="line">  nodeName: &lt;string&gt; <span class="comment">#设置NodeName表示将该Pod调度到指定到名称的node节点上</span></span><br><span class="line">  nodeSelector: obeject <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span></span><br><span class="line">  imagePullSecrets: <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line">  - name: string</span><br><span class="line">  hostNetwork: <span class="literal">false</span> <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line">  volumes: <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line">    - name: string <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line">      emptyDir: &#123;&#125; <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line">      hostPath: string <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line">        path: string <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line">      secret: <span class="comment">#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span></span><br><span class="line">        scretname: string</span><br><span class="line">        items:</span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">    configMap: <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line">      name: string</span><br><span class="line">      items:</span><br><span class="line">      - key: string</span><br><span class="line">        path: string</span><br></pre></td></tr></table></figure>
<h4 id="管理pod中容器"><a href="#管理pod中容器" class="headerlink" title="管理pod中容器"></a>管理pod中容器</h4><h5 id="镜像及其获取策略"><a href="#镜像及其获取策略" class="headerlink" title="镜像及其获取策略"></a>镜像及其获取策略</h5></li>
<li>kubernetes支持用户自定义镜像文件的获取策略<br>Always：镜像标签为latest或镜像不存在时总是从指定的仓库中获取镜像<br>IfNotPresent：仅当本地镜像缺失时方才从目标仓库下载镜像<br>Never：禁止从仓库下载镜像，即仅使用本地镜像<br><strong>镜像tag为具体版本号， 默认策略是：IfNotPresent<br>镜像tag为：latest，默认策略是always</strong><h5 id="暴露端口"><a href="#暴露端口" class="headerlink" title="暴露端口"></a>暴露端口</h5>Docker的网络模型中，使用默认网络的容器化应用需要通过NAT将其暴露到外部网络中才能被其他节点之上的容器客户端所访问。<strong>kubernetes系统的网络模型中，各pod的ip地址处于同一网络平面上，无论是否为容器指定了要暴露的端口，都不会影响集群中其他节点之上的pod客户端对其进行访问，这就意味着，任何监听在非lo接口的端口都可以通过pod网络直接被请求</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定暴露端口为tcp的80，并将之命名为http</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-example</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">      protocol: TCP</span><br></pre></td></tr></table></figure>
<h5 id="自定义运行的容器化应用"><a href="#自定义运行的容器化应用" class="headerlink" title="自定义运行的容器化应用"></a>自定义运行的容器化应用</h5>容器的command字段能够指定不同于镜像默认运行的应用程序，并且可以同时使用args字段进行参数传递，他们将覆盖镜像中的默认定义。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充一个命令: kubectl exec pod名称 -n 命名空间 -it -c 容器名称 /bin/sh 在容器内部执行命令</span></span><br><span class="line"><span class="comment"># cat pod1.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-example</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">    args: [<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do sleep 30;done&quot;</span>]</span><br><span class="line"><span class="comment"># yaml文件</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-command</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox:1.30</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/hello.txt;while true;do /bin/echo <span class="subst">$(date +%T)</span> &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;</span>]</span><br><span class="line"><span class="comment"># 如果command和args均没有写，那么用Dockerfile的配置。</span></span><br><span class="line"><span class="comment"># 如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command</span></span><br><span class="line"><span class="comment"># 如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数</span></span><br><span class="line"><span class="comment"># 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数</span></span><br></pre></td></tr></table></figure>
<h5 id="pod资源限制"><a href="#pod资源限制" class="headerlink" title="pod资源限制"></a>pod资源限制</h5>在kubernetes上，可由容器或Pod请求或消费的计算资源指的是cpu和内存。cpu属于可压缩型资源，即资源额度可按需收缩，而<strong>内存则是不可压缩型资源</strong>，对其执行收缩操作可能会导致某种程度的问题。<br>资源隔离属于容器级别，cpu和内存资源的配置需要在Pod中的容器上进行，每种资源均可由requests属性定义其请求的确保可用值(最小值)，即容器运行可能用不到这些额度的资源，但用到时必须确保由如此多的资源可用，而limits属性则用于限制资源的可用的最大值。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod frontend <span class="comment"># 查看pod描述</span></span><br><span class="line"><span class="comment"># cat pod-stress-ng.yaml</span></span><br><span class="line"><span class="comment"># limits是对资源的总限制、requests是最低分配的资源。requests一般要比limits要小一些</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: db</span><br><span class="line">    image: mysql</span><br><span class="line">    <span class="built_in">env</span>:</span><br><span class="line">    - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">      value: <span class="string">&quot;password&quot;</span></span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        cpu: <span class="string">&quot;250m&quot;</span></span><br><span class="line">      limits:</span><br><span class="line">        memory: <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        cpu: <span class="string">&quot;500m&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5>通过环境变量配置容器化应用时，需要在容器配置段中嵌套使用env字段<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-env</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox:1.30</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do /bin/echo <span class="subst">$(date +%T)</span> &gt;&gt;</span></span><br><span class="line"><span class="string">/tmp/hello.txt;sleep 60; done;&quot;</span>]</span><br><span class="line">    <span class="built_in">env</span>: <span class="comment"># 设置环境变量列表</span></span><br><span class="line">    - name: <span class="string">&quot;username&quot;</span></span><br><span class="line">      value: <span class="string">&quot;admin&quot;</span></span><br><span class="line">    - name: <span class="string">&quot;password&quot;</span></span><br><span class="line">      value: <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="共享节点的网络名称空间"><a href="#共享节点的网络名称空间" class="headerlink" title="共享节点的网络名称空间"></a>共享节点的网络名称空间</h5>同一个pod对象的各容器均运行于一个独立的、隔离的Network名称空间中，共享同一个网络协议栈及相关的网络设备。也有一些特殊的pod对象需要运行于所在节点的名称空间中，执行系统级的管理任务。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-example</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:1.8</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    containerPort: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">  <span class="built_in">command</span>: [<span class="string">&quot;nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line">hostNetwork: True</span><br></pre></td></tr></table></figure>
<h4 id="标签与标签选择器"><a href="#标签与标签选择器" class="headerlink" title="标签与标签选择器"></a>标签与标签选择器</h4>标签是键值类型的数据，他们可用于资源创建时直接指定，也可随时按需添加于活动对象中。<br>创建资源时，可以直接在其metadata中嵌套使用labels字段以定义要附加的标签项。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-example</span><br><span class="line">  labels:</span><br><span class="line">    <span class="built_in">env</span>: qa</span><br><span class="line">    tier: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">    ports:</span><br><span class="line">  - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">  <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">  args: [<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do sleep 30;done&quot;</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 展示标签</span></span><br><span class="line">kubectl get pods pod-example --show-labels</span><br><span class="line"><span class="comment"># 指定显示特定标签</span></span><br><span class="line">kubectl get pods pod-example -L <span class="built_in">env</span>,tier</span><br><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line">kubectl label pods/pod-example env2=production</span><br><span class="line"><span class="comment"># 覆盖</span></span><br><span class="line">kubectl label pods/pod-example <span class="built_in">env</span>=qq --overwrite</span><br><span class="line"><span class="comment"># 选择出env不等于qq的pod</span></span><br><span class="line">kubectl get pods -l <span class="string">&quot;env!=qq&quot;</span> --show-labels</span><br><span class="line"><span class="comment"># 多个标签选择器</span></span><br><span class="line">kubectl get pods -l <span class="string">&quot;env=qq,tier=frontend&quot;</span> --show-labels</span><br><span class="line"><span class="comment"># 显示值为production或dev中的一个的所有pod</span></span><br><span class="line">kubectl get pods -l <span class="string">&quot;env in (qq,qa)&quot;</span> --show-labels</span><br><span class="line"><span class="comment"># 显示所有存在env标签的pod</span></span><br><span class="line">kubectl get pods -l <span class="string">&quot;env &quot;</span> --show-labels</span><br><span class="line"><span class="comment"># 显示所有不存在env标签，但有app的标签的pod</span></span><br><span class="line">kubectl get pods -l <span class="string">&#x27;!env,app&#x27;</span> --show-labels</span><br></pre></td></tr></table></figure>
<h5 id="pod节点选择器"><a href="#pod节点选择器" class="headerlink" title="pod节点选择器"></a>pod节点选择器</h5>pod节点选择器是标签及标签选择器的一种应用，它能够让pod对象基于集群中工作节点的标签来挑选倾向运行的目标节点。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-example</span><br><span class="line">  labels:</span><br><span class="line">    <span class="built_in">env</span>: qa</span><br><span class="line">    tier: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">    args: [<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do sleep 30;done&quot;</span>]</span><br><span class="line">  nodeSelector:</span><br><span class="line">    disktype: ssd</span><br><span class="line"><span class="comment"># 指定pod资源调度至这些具有ssd设备的节点上，只需要为其使用spec.nodeSelector标签选择器</span></span><br><span class="line"><span class="comment">#  kubectl get pods pod-example -o wide</span></span><br></pre></td></tr></table></figure>
<h4 id="pod对象的生命周期"><a href="#pod对象的生命周期" class="headerlink" title="pod对象的生命周期"></a>pod对象的生命周期</h4><img src="/image/docker/13.jpg" alt=" "><br>挂起（Pending）：<strong>apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</strong><br>运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成<br>成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启<br>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态<br>未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致<h5 id="pod的创建过程"><a href="#pod的创建过程" class="headerlink" title="pod的创建过程"></a>pod的创建过程</h5><img src="/image/docker/14.jpg" alt=" "></li>
</ul>
<ol>
<li>用户通过kubectl或其他api客户端提交pod spec给api server</li>
<li>api server尝试着将pod对象的相关信息存入etcd中，待写入操作执行完成，api server即会返回确认信息至客户端</li>
<li>api server开始反应etcd中的状态变化</li>
<li>所有的kubernetes组件均使用watch机制来跟踪检查api server上的相关的变动</li>
<li>kube-scheduler（调度器）通过其watch觉察到api server创建了新的pod对象但尚未绑定至任何工作节点</li>
<li>kube-scheduler为pod对象挑选一个工作节点并将结果信息更新至api server</li>
<li>调度结果信息由api server更新至etcd存储系统中，而且api server也开始反映此pod对象的调度结果</li>
<li>pod被调度到的目标工作节点上的kubelet尝试在当前节点上调用docker启动容器，并将容器的结果状态回送至api server</li>
<li>api server将pod状态信息存入etcd中</li>
<li>在etcd确认写入操作成功完成之后，api server将确认信息发送至相关的kubelet事件将通过它被接收<h5 id="pod的终止过程"><a href="#pod的终止过程" class="headerlink" title="pod的终止过程"></a>pod的终止过程</h5><img src="/image/docker/15.jpg" alt=" "></li>
<li>用户发送删除pod对象的命令</li>
<li>api服务器中的pod对象会随着事件的推移而更新，在宽限期内（默认为30秒），pod被视为“dead”</li>
<li>将pod标记为terminating状态</li>
<li>（与第三步同时运行）kubelet在监控到pod对象转为“Terminating”状态的同时启动Pod关闭过程</li>
<li>（与第三步同时运行）端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service<br>源的端点列表中移除</li>
<li>如果当前Pod对象定义了preStop钩子处理器，则在其标记为“terminating”后即会以同步的方式启动执行；如若宽限期结束后，preStop仍未执行结束，则第2步会被重新执行并额外获取一个时长为2秒的小宽限期。</li>
<li>Pod对象中的容器进程收到TERM信号。</li>
<li>宽限期结束后，若存在任何一个仍在运行的进程，那么Pod对象即会收到SIGKILL信号</li>
<li>Kubelet请求API Server将此Pod资源的宽限期设置为0从而完成删除操作，它变得对用户不再可见<h5 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h5>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码<br><strong>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数</strong><br>post start：容器创建之后执行，如果失败了会重启容器<br>pre stop ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li>
</ol>
<ul>
<li>钩子处理器支持三种方式定义动作<br>Exec命令：在容器内执行一次命令<br>TCPSocket：在当前容器尝试访问指定的socket<br>HTTPGet：在当前容器中向某url发起http请求<h5 id="pod存活性探测"><a href="#pod存活性探测" class="headerlink" title="pod存活性探测"></a>pod存活性探测</h5>不少应用程序长时间持续运行后会逐渐转为不可用状态，并且能够通过重启操作恢复，kubernetes的容器存活性探测机制可发现诸如此类的问题，并依据探测结果结合重启策略出发后续的行为。存活性探测是隶属于容器级别的配置，kubelet可基于它判定何时需要重启一个容器</li>
</ul>
<p>liveness probes：<strong>存活性探针</strong>，用于检测应用实例当前是否处于<strong>正常运行</strong>状态，如果不是，k8s会重启容器<br>readiness probes：<strong>就绪性探针</strong>，用于检测应用实例当前是否可以<strong>接收请求</strong>，如果不能，k8s不会转发流量</p>
<h5 id="容器的重启策略"><a href="#容器的重启策略" class="headerlink" title="容器的重启策略"></a>容器的重启策略</h5><p>重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p>
<p>Always ：容器失效时，自动重启该容器，这也是默认值。<br>OnFailure ： 容器终止运行且退出码不为0时重启<br>Never ： 不论状态为何，都不重启该容器</p>
<h5 id="Pod调度"><a href="#Pod调度" class="headerlink" title="Pod调度"></a>Pod调度</h5><p>默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些Pod到达某些节点上，这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式：<br><strong>自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出<br>定向调度：NodeName、NodeSelector<br>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity<br>污点（容忍）调度：Taints、Toleration</strong></p>
<h6 id="定向调度"><a href="#定向调度" class="headerlink" title="定向调度"></a>定向调度</h6><p>定向调度，指的是利用在pod上声明nodeName或者nodeSelector，以此将Pod调度到期望的node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过pod运行失败而已。<br>NodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。<br>NodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现。</p>
<h6 id="亲和性调度"><a href="#亲和性调度" class="headerlink" title="亲和性调度"></a>亲和性调度</h6><p><strong>亲和性：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。<br>反亲和性：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用性。</strong><br>nodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题<br>podAffinity(pod亲和性) : 以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题<br>podAntiAffinity(pod反亲和性) : 以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题</p>
<h3 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h3><p>Pod是kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：<br><strong>自主式pod：kubernetes直接创建出来的Pod，这种pod删除后就没有了，也不会重建<br>控制器创建的pod：kubernetes通过控制器创建的pod，这种pod删除了之后还会自动重建</strong></p>
<ul>
<li>什么是Pod控制器<br>Pod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。<br>kubernetes中，有很多类型的pod控制器<br>ReplicationController：比较原始的pod控制器，已经被废弃，由ReplicaSet替代<br>ReplicaSet：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级<br>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本<br>Horizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷<br>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务<br>Job：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务<br>Cronjob：它创建的Pod负责周期性任务控制，不需要持续后台运行<h4 id="ReplicaSet-RS"><a href="#ReplicaSet-RS" class="headerlink" title="ReplicaSet(RS)"></a>ReplicaSet(RS)</h4><img src="/image/docker/16.jpg" alt=" "><br>ReplicaSet的主要作用是<strong>保证一定数量的pod正常运行</strong>，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。</li>
<li>创建ReplicaSet<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</span></span><br><span class="line"><span class="comment"># selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</span></span><br><span class="line"><span class="comment"># template：模板，就是当前控制器创建pod所使用的模板板，里面其实就是前一章学过的pod的定义</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: pc-replicaset</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:latest</span><br><span class="line"><span class="comment"># kubectl get rs pc-replicaset -n dev -o wide</span></span><br><span class="line"><span class="comment"># DESIRED:期望副本数量</span></span><br><span class="line"><span class="comment"># CURRENT:当前副本数量</span></span><br><span class="line"><span class="comment"># READY:已经准备好提供服务的副本数量</span></span><br></pre></td></tr></table></figure></li>
<li>扩缩容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑rs的副本数量，修改spec:replicas即可</span></span><br><span class="line">kubectl edit rs pc-replicaset -n dev</span><br><span class="line"><span class="comment"># 使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可</span></span><br><span class="line">kubectl scale rs pc-replicaset --replicas=2 -n dev</span><br></pre></td></tr></table></figure></li>
<li>镜像升级<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.直接修改image: nginx:1.17.2</span></span><br><span class="line"><span class="comment"># 2.命令</span></span><br><span class="line">kubectl <span class="built_in">set</span> image rs pc-replicaset nginx=nginx:1.17.1 -n dev</span><br></pre></td></tr></table></figure></li>
<li>删除ReplicaSet<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete rs pc-replicaset -n dev</span><br><span class="line"><span class="comment"># 如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade=false选项（不推荐）。</span></span><br><span class="line">kubectl delete rs pc-replicaset -n dev --cascade=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 使用yaml直接删除(推荐)</span></span><br><span class="line">kubectl delete -f pc-replicaset.yaml</span><br></pre></td></tr></table></figure>
<h4 id="Deployment-Deploy"><a href="#Deployment-Deploy" class="headerlink" title="Deployment(Deploy)"></a>Deployment(Deploy)</h4>kubernetes在V1.2版本开始，引入了Deployment控制器。这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod<br><img src="/image/docker/17.jpg" alt=" "></li>
<li>功能<br>支持ReplicaSet的所有功能<br>支持发布的停止、继续<br>支持滚动升级和回滚版本</li>
<li>Deployment的资源清单文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1 <span class="comment"># 版本号</span></span><br><span class="line">kind: Deployment <span class="comment"># 类型</span></span><br><span class="line">metadata: <span class="comment"># 元数据</span></span><br><span class="line">  name: <span class="comment"># rs名称</span></span><br><span class="line">  namespace: <span class="comment"># 所属命名空间</span></span><br><span class="line">  labels: <span class="comment">#标签</span></span><br><span class="line">    controller: deploy</span><br><span class="line">spec: <span class="comment"># 详情描述</span></span><br><span class="line">  replicas: 3 <span class="comment"># 副本数量</span></span><br><span class="line">  revisionHistoryLimit: 3 <span class="comment"># 保留历史版本</span></span><br><span class="line">  paused: <span class="literal">false</span> <span class="comment"># 暂停部署，默认是false</span></span><br><span class="line">  progressDeadlineSeconds: 600 <span class="comment"># 部署超时时间（s），默认是600</span></span><br><span class="line">  strategy: <span class="comment"># 策略</span></span><br><span class="line">    <span class="built_in">type</span>: RollingUpdate <span class="comment"># 滚动更新策略</span></span><br><span class="line">    rollingUpdate: <span class="comment"># 滚动更新</span></span><br><span class="line">      maxSurge: 30% <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      maxUnavailable: 30% <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  selector: <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    matchLabels: <span class="comment"># Labels匹配规则</span></span><br><span class="line">      app: nginx-pod</span><br><span class="line">    matchExpressions: <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      - &#123;key: app, operator: In, values: [nginx-pod]&#125;</span><br><span class="line">  template: <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.17.1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure></li>
<li>创建deployment<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: pc-deployment</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.17.1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看deployment</span></span><br><span class="line"><span class="comment"># UP-TO-DATE 最新版本的pod的数量</span></span><br><span class="line"><span class="comment"># AVAILABLE 当前可用的pod的数量</span></span><br><span class="line">kubectl get deploy pc-deployment -n dev</span><br></pre></td></tr></table></figure></li>
<li>扩缩容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变更副本数量为5个</span></span><br><span class="line">kubectl scale deploy pc-deployment --replicas=5 -n dev</span><br></pre></td></tr></table></figure></li>
<li>镜像更新<br><strong>deployment支持两种更新策略: 重建更新 和 滚动更新 ,可以通过 strategy 指定策略类型,支持两个属性</strong><br>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34556414/article/details/109603303">https://blog.csdn.net/qq_34556414/article/details/109603303</a><br>strategy：指定新的Pod替换旧的Pod的策略， 支持两个属性：<br>type：指定策略类型，支持两种策略<br>Recreate：在创建出新的Pod之前会先杀掉所有已存在的Pod<br>RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本<br>Pod<br>rollingUpdate：当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：<br>maxUnavailable：用来指定在升级过程中不可用Pod的最大数量，默认为25%。<br>maxSurge： 用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。<br>maxUnavailable：和期望ready的副本数比，不可用副本数最大比例（或最大值），这个值越小，越能保证服务稳定，更新越平滑；<br>maxSurge：和期望ready的副本数比，超过期望副本数最大比例（或最大值），这个值调的越大，副本更新速度越快</li>
<li>重建更新<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  strategy: <span class="comment"># 策略</span></span><br><span class="line">    <span class="built_in">type</span>: Recreate <span class="comment"># 重建更新</span></span><br></pre></td></tr></table></figure></li>
<li>滚动更新<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  strategy: <span class="comment"># 策略</span></span><br><span class="line">    <span class="built_in">type</span>: RollingUpdate <span class="comment"># 滚动更新策略</span></span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 25%</span><br><span class="line">      maxUnavailable: 25%</span><br></pre></td></tr></table></figure></li>
<li>版本回退<br>status 显示当前升级状态<br>history 显示 升级历史记录<br>pause 暂停版本升级过程<br>resume 继续已经暂停的版本升级过程<br>restart 重启版本升级过程<br>undo 回滚到上一级版本（可以使用–to-revision回滚到指定版本）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前升级版本的状态</span></span><br><span class="line">kubectl rollout status deploy pc-deployment -n dev</span><br><span class="line"><span class="comment"># 查看升级历史记录</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deploy pc-deployment -n dev</span><br><span class="line"><span class="comment"># 直接使用--to-revision=1回滚到了1版本，如果省略这个选项，就是回退到上个版本，就是2版本</span></span><br><span class="line">kubectl rollout undo deployment pc-deployment --to-revision=1 -n dev</span><br></pre></td></tr></table></figure></li>
<li>金丝雀发布<br>有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是<br>所谓的金丝雀发布。</li>
<li>删除Deployment<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除deployment，其下的rs和pod也将被删除</span></span><br><span class="line">kubectl delete -f pc-deployment.yaml</span><br></pre></td></tr></table></figure>
<h4 id="Horizontal-Pod-Autoscaler-HPA"><a href="#Horizontal-Pod-Autoscaler-HPA" class="headerlink" title="Horizontal Pod Autoscaler(HPA)"></a>Horizontal Pod Autoscaler(HPA)</h4>HPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数，这是HPA的实现原理。<br><img src="/image/docker/18.jpg" alt=" "></li>
<li>测试实验<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># metrics-server可以用来收集集群中的资源使用情况</span></span><br><span class="line">yum install git -y</span><br><span class="line">git <span class="built_in">clone</span> -b v0.3.6 https://github.com/kubernetes-incubator/metrics-server</span><br><span class="line"><span class="comment"># 修改deployment, 注意修改的是镜像和初始化参数</span></span><br><span class="line"><span class="built_in">cd</span> /root/metrics-server/deploy/1.8+/</span><br><span class="line">vim metrics-server-deployment.yaml</span><br><span class="line"><span class="comment"># hostNetwork: true</span></span><br><span class="line"><span class="comment"># image: registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6</span></span><br><span class="line"><span class="comment"># args:</span></span><br><span class="line"><span class="comment"># - --kubelet-insecure-tls</span></span><br><span class="line"><span class="comment"># - --kubelet-preferred-address-# types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP</span></span><br><span class="line"><span class="comment"># 安装metrics-server</span></span><br><span class="line">kubectl apply -f ./ <span class="comment">#  如果有版本报错，可以改一下对应配置文件中的api版本</span></span><br><span class="line"><span class="comment"># 准备deployment和service vim pc-hpa-pod.yam</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  strategy: <span class="comment"># 策略</span></span><br><span class="line">    <span class="built_in">type</span>: RollingUpdate <span class="comment"># 滚动更新策略</span></span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.17.1</span><br><span class="line">        resources: <span class="comment"># 资源配额</span></span><br><span class="line">          limits: <span class="comment"># 限制资源（上限）</span></span><br><span class="line">          cpu: <span class="string">&quot;1&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        requests: <span class="comment"># 请求资源（下限）</span></span><br><span class="line">          cpu: <span class="string">&quot;100m&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">kubectl expose deployment nginx --<span class="built_in">type</span>=NodePort --port=80 -n dev</span><br><span class="line"><span class="comment"># 部署HPA pc-hpa.yaml</span></span><br><span class="line">apiVersion: autoscaling/v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: pc-hpa</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  minReplicas: 1 <span class="comment">#最小pod数量</span></span><br><span class="line">  maxReplicas: 10 <span class="comment">#最大pod数量</span></span><br><span class="line">  targetCPUUtilizationPercentage: 3 <span class="comment"># CPU使用率指标</span></span><br><span class="line">  scaleTargetRef: <span class="comment"># 指定要控制的nginx信息</span></span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: nginx</span><br><span class="line"><span class="comment"># 创建hpa</span></span><br><span class="line">kubectl create -f pc-hpa.yaml</span><br><span class="line"><span class="comment"># 查看hpa</span></span><br><span class="line">kubectl get hpa -n dev</span><br></pre></td></tr></table></figure>
<h4 id="DaemonSet-DS"><a href="#DaemonSet-DS" class="headerlink" title="DaemonSet(DS)"></a>DaemonSet(DS)</h4>DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。<br><strong>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上<br>当节点从集群中移除时，Pod 也就被垃圾回收了</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1 <span class="comment"># 版本号</span></span><br><span class="line">kind: DaemonSet <span class="comment"># 类型</span></span><br><span class="line">metadata: <span class="comment"># 元数据</span></span><br><span class="line">  name: <span class="comment"># 名称</span></span><br><span class="line">  namespace: <span class="comment"># 所属命名空间</span></span><br><span class="line">  labels: <span class="comment">#标签</span></span><br><span class="line">    controller: daemonset</span><br><span class="line">spec: <span class="comment"># 详情描述</span></span><br><span class="line">  revisionHistoryLimit: 3 <span class="comment"># 保留历史版本</span></span><br><span class="line">  updateStrategy: <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="built_in">type</span>: RollingUpdate <span class="comment"># 滚动更新策略</span></span><br><span class="line">    rollingUpdate: <span class="comment"># 滚动更新</span></span><br><span class="line">      maxUnavailable: 1 <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  selector: <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">  matchLabels: <span class="comment"># Labels匹配规则</span></span><br><span class="line">    app: nginx-pod</span><br><span class="line">  matchExpressions: <span class="comment"># Expressions匹配规则</span></span><br><span class="line">    - &#123;key: app, operator: In, values: [nginx-pod]&#125;</span><br><span class="line">  template: <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.17.1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>
<h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4>用于负责批量处理(一次要处理指定数量任务)短暂的一次性(每个任务仅运行一次就结束)任务。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1 <span class="comment"># 版本号</span></span><br><span class="line">kind: Job <span class="comment"># 类型</span></span><br><span class="line">metadata: <span class="comment"># 元数据</span></span><br><span class="line">  name: <span class="comment"># 名称</span></span><br><span class="line">  namespace: <span class="comment"># 所属命名空间</span></span><br><span class="line">  labels: <span class="comment">#标签</span></span><br><span class="line">    controller: job</span><br><span class="line">spec: <span class="comment"># 详情描述</span></span><br><span class="line">  completions: 1 <span class="comment"># 指定job需要成功运行Pods的次数。默认值: 1</span></span><br><span class="line">  parallelism: 1 <span class="comment"># 指定job在任一时刻应该并发运行Pods的数量。默认值: 1</span></span><br><span class="line">  activeDeadlineSeconds: 30 <span class="comment"># 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。</span></span><br><span class="line">  backoffLimit: 6 <span class="comment"># 指定job失败后进行重试的次数。默认是6</span></span><br><span class="line">  manualSelector: <span class="literal">true</span> <span class="comment"># 是否可以使用selector选择器选择pod，默认是false</span></span><br><span class="line">  selector: <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    matchLabels: <span class="comment"># Labels匹配规则</span></span><br><span class="line">      app: counter-pod</span><br><span class="line">    matchExpressions: <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      - &#123;key: app, operator: In, values: [counter-pod]&#125;</span><br><span class="line">  template: <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: counter-pod</span><br><span class="line">    spec:</span><br><span class="line">      restartPolicy: Never <span class="comment"># 重启策略只能设置为Never或者OnFailure</span></span><br><span class="line">      containers:</span><br><span class="line">      - name: counter</span><br><span class="line">        image: busybox:1.30</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo <span class="variable">$i</span>;sleep 2;done&quot;</span>]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变</span></span><br><span class="line"><span class="comment"># 如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1</span></span><br><span class="line"><span class="comment"># 如果指定为Always的话，就意味着一直重启，意味着job任务会重复去执行了，当然不对，所以不能设置为Always</span></span><br></pre></td></tr></table></figure>
<h4 id="CronJob-CJ"><a href="#CronJob-CJ" class="headerlink" title="CronJob(CJ)"></a>CronJob(CJ)</h4>CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行时间点及重复运行的方式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1beta1 <span class="comment"># 版本号</span></span><br><span class="line">kind: CronJob <span class="comment"># 类型</span></span><br><span class="line">metadata: <span class="comment"># 元数据</span></span><br><span class="line">  name: <span class="comment"># rs名称</span></span><br><span class="line">  namespace: <span class="comment"># 所属命名空间</span></span><br><span class="line">  labels: <span class="comment">#标签</span></span><br><span class="line">    controller: cronjob</span><br><span class="line">spec: <span class="comment"># 详情描述</span></span><br><span class="line">  schedule: <span class="comment"># cron格式的作业调度运行时间点,用于控制任务在什么时间执行</span></span><br><span class="line">  concurrencyPolicy: <span class="comment"># 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业</span></span><br><span class="line">  failedJobHistoryLimit: <span class="comment"># 为失败的任务执行保留的历史记录数，默认为1</span></span><br><span class="line">  successfulJobHistoryLimit: <span class="comment"># 为成功的任务执行保留的历史记录数，默认为3</span></span><br><span class="line">  startingDeadlineSeconds: <span class="comment"># 启动作业错误的超时时长</span></span><br><span class="line">  jobTemplate: <span class="comment"># job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义</span></span><br></pre></td></tr></table></figure>
<h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3>kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是<strong>pod的ip地址不是固定的</strong>，这也就意味着不方便直接采用pod的ip对服务进行访问。<br>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。<br><img src="/image/docker/26.jpg" alt=" "><br><strong>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程</strong>，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后它会将最新的Service信息转换成对应的访问规则。<h4 id="kube-proxy工作模式"><a href="#kube-proxy工作模式" class="headerlink" title="kube-proxy工作模式"></a>kube-proxy工作模式</h4><h5 id="userspace-模式"><a href="#userspace-模式" class="headerlink" title="userspace 模式"></a>userspace 模式</h5>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。 该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。<h5 id="iptables-模式"><a href="#iptables-模式" class="headerlink" title="iptables 模式"></a>iptables 模式</h5>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。 该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。<h5 id="ipvs-模式"><a href="#ipvs-模式" class="headerlink" title="ipvs 模式"></a>ipvs 模式</h5>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此模式必须安装ipvs内核模块，否则会降级为iptables</span></span><br><span class="line"><span class="comment"># 开启ipvs</span></span><br><span class="line">kubectl edit cm kube-proxy -n kube-system</span><br><span class="line"><span class="comment"># 修改mode: &quot;ipvs&quot;</span></span><br><span class="line">kubectl delete pod -l k8s-app=kube-proxy -n kube-system</span><br></pre></td></tr></table></figure>
<h4 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h4>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问<br>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务<br>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持<br>ExternalName： 把集群外部的服务引入集群内部，直接使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kind: Service <span class="comment"># 资源类型</span></span><br><span class="line">apiVersion: v1 <span class="comment"># 资源版本</span></span><br><span class="line">metadata: <span class="comment"># 元数据</span></span><br><span class="line">  name: service <span class="comment"># 资源名称</span></span><br><span class="line">  namespace: dev <span class="comment"># 命名空间</span></span><br><span class="line">spec: <span class="comment"># 描述</span></span><br><span class="line">  selector: <span class="comment"># 标签选择器，用于确定当前service代理哪些pod</span></span><br><span class="line">    app: nginx</span><br><span class="line">  <span class="built_in">type</span>: <span class="comment"># Service类型，指定service的访问方式</span></span><br><span class="line">  clusterIP: <span class="comment"># 虚拟服务的ip地址</span></span><br><span class="line">  sessionAffinity: <span class="comment"># session亲和性，支持ClientIP、None两个选项</span></span><br><span class="line">  ports: <span class="comment"># 端口信息</span></span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 3017 <span class="comment"># service端口</span></span><br><span class="line">      targetPort: 5003 <span class="comment"># pod端口</span></span><br><span class="line">      nodePort: 31122 <span class="comment"># 主机端口</span></span><br></pre></td></tr></table></figure>
<h4 id="Service使用"><a href="#Service使用" class="headerlink" title="Service使用"></a>Service使用</h4><strong>实验环境准备</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建deployment.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: pc-deployment</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.8</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>
<h5 id="ClusterIP类型的Service"><a href="#ClusterIP类型的Service" class="headerlink" title="ClusterIP类型的Service"></a>ClusterIP类型的Service</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service-clusterip.yaml文件</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-clusterip</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-pod</span><br><span class="line">  clusterIP: 172.16.66.66 <span class="comment"># service的ip地址，如果不写，默认会生成一个</span></span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    targetPort: 80 <span class="comment"># pod端口</span></span><br><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">kubectl create -f service-clusterip.yaml</span><br><span class="line"><span class="comment"># 查看service的详细信息</span></span><br><span class="line"><span class="comment"># 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口</span></span><br><span class="line">kubectl describe svc service-clusterip -n dev</span><br><span class="line"><span class="comment"># 查看ipvs的映射规则</span></span><br><span class="line">ipvsadm -Ln</span><br></pre></td></tr></table></figure></li>
<li>Endpoint<br>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。<br><img src="/image/docker/27.jpg" alt=" "> </li>
<li>负载分发策略<br>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：<br>如果不定义，<strong>默认使用kube-proxy的策略，比如随机、轮询</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看ipvs的映射规则【rr 轮询】</span></span><br><span class="line">ipvsadm -Ln</span><br><span class="line"><span class="comment"># 循环访问测试</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span> curl 172.16.66.66:80; <span class="built_in">sleep</span> 5; <span class="keyword">done</span>;</span><br><span class="line"><span class="comment"># 修改分发策略----sessionAffinity:ClientIP</span></span><br><span class="line"><span class="comment"># 查看ipvs规则【persistent 代表持久】</span></span><br><span class="line">ipvsadm -Ln</span><br><span class="line"><span class="comment"># 循环访问测试</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span> curl 10.97.97.97; <span class="built_in">sleep</span> 5; <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure>
<h5 id="HeadLess类型的Service"><a href="#HeadLess类型的Service" class="headerlink" title="HeadLess类型的Service"></a>HeadLess类型的Service</h5>开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，<br>针对这种情况，kubernetes提供了HeadLiness Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建service-headliness.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-headliness</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-pod</span><br><span class="line">  clusterIP: None <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">kubectl create -f service-headliness.yaml</span><br><span class="line"><span class="comment"># 获取service， 发现CLUSTER-IP未分配</span></span><br><span class="line">kubectl get svc service-headliness -n dev -o wide</span><br><span class="line"><span class="comment"># 查看service详情</span></span><br><span class="line">kubectl describe svc service-headliness -n dev</span><br><span class="line"><span class="comment"># 查看域名的解析情况</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pc-deployment-xxxxxxxxxxx -n dev -- /bin/sh</span><br><span class="line">dig @172.16.0.10 service-headliness.dev.svc.cluster.local</span><br></pre></td></tr></table></figure>
<h5 id="NodePort类型的Service"><a href="#NodePort类型的Service" class="headerlink" title="NodePort类型的Service"></a>NodePort类型的Service</h5>创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是将service的端口映射到Node的一个端口上，然后就可以通过 NodeIp:NodePort 来访问service了。<br><img src="/image/docker/28.jpg" alt=" "> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-nodeport</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-pod</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># service类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    nodePort: 30002 <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line">    targetPort: 80</span><br></pre></td></tr></table></figure>
<h5 id="LoadBalancer类型的Service"><a href="#LoadBalancer类型的Service" class="headerlink" title="LoadBalancer类型的Service"></a>LoadBalancer类型的Service</h5>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。<br><img src="/image/docker/29.jpg" alt=" "> <h5 id="ExternalName类型的Service"><a href="#ExternalName类型的Service" class="headerlink" title="ExternalName类型的Service"></a>ExternalName类型的Service</h5>ExternalName类型的Service用于引入集群外部的服务，它通过 externalName 属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。<br><img src="/image/docker/30.jpg" alt=" "> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-externalname</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ExternalName <span class="comment"># service类型</span></span><br><span class="line">  externalName: www.baidu.com <span class="comment">#改成ip地址也可以</span></span><br></pre></td></tr></table></figure>
<h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4>service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。</li>
<li>工作原理</li>
</ul>
<ol>
<li>用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service</li>
<li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置</li>
<li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新</li>
<li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则<br><img src="/image/docker/31.jpg" alt=" "> <h5 id="Ingress使用"><a href="#Ingress使用" class="headerlink" title="Ingress使用"></a>Ingress使用</h5>官方教程地址：<a target="_blank" rel="noopener" href="https://kubernetes.github.io/ingress-nginx/deploy/#bare-metal">https://kubernetes.github.io/ingress-nginx/deploy/#bare-metal</a></li>
</ol>
<ul>
<li>搭建ingress环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master下载deploy.yaml</span></span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/baremetal/deploy.yaml</span><br><span class="line"><span class="comment"># 在所有节点上提前pull镜像，防止启动失败</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/eagleslab/service:ingresswebhook111</span><br><span class="line">docker tag c41e9fcadf5a k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.1.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/eagleslab/service:ingresscontroller104</span><br><span class="line">docker tag a9f76bcccfb5 k8s.gcr.io/ingress-nginx/controller:v1.0.4</span><br><span class="line">docker images |grep k8s.gcr</span><br><span class="line"><span class="comment"># 如果是提前pull的镜像，要删除掉deploy.yaml中对镜像sha256的检查，在image标签中，删除@sha256到行尾</span></span><br><span class="line">sed -i <span class="string">&#x27;s/@sha256:.*//g&#x27;</span> deploy.yaml</span><br><span class="line">kubectl apply -f deploy.yaml</span><br><span class="line"><span class="comment"># 查看ingress-nginx</span></span><br><span class="line">kubectl get pods -n ingress-nginx -l app.kubernetes.io/name=ingress-nginx --watch</span><br><span class="line">kubectl get pods -n ingress-nginx -l app.kubernetes.io/name=ingress-nginx</span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">kubectl get svc -n ingress-nginx</span><br></pre></td></tr></table></figure>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><h4 id="基本存储"><a href="#基本存储" class="headerlink" title="基本存储"></a>基本存储</h4><h5 id="EmptyDir"><a href="#EmptyDir" class="headerlink" title="EmptyDir"></a>EmptyDir</h5>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录</li>
<li>用途<br>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留<br>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li>
<li>案例<br><img src="/image/docker/22.jpg" alt=" "><br>在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: volume-emptydir</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">  image: nginx:1.17.1</span><br><span class="line">  ports:</span><br><span class="line">  - containerPort: 80</span><br><span class="line">  volumeMounts: <span class="comment"># 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx</span></span><br><span class="line">  - name: logs-volume</span><br><span class="line">    mountPath: /var/log/nginx</span><br><span class="line">- name: busybox</span><br><span class="line">  image: busybox:1.30</span><br><span class="line">  <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] <span class="comment"># 初始命令，动态读取指定文件中内容</span></span><br><span class="line">  volumeMounts: <span class="comment"># 将logs-volume 挂在到busybox容器中，对应的目录为 /logs</span></span><br><span class="line">  - name: logs-volume</span><br><span class="line">    mountPath: /logs</span><br><span class="line">  volumes: <span class="comment"># 声明volume， name为logs-volume，类型为emptyDir</span></span><br><span class="line">  - name: logs-volume</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">kubectl create -f volume-emptydir.yaml</span><br><span class="line"><span class="comment"># 通过kubectl logs命令查看指定容器的标准输出</span></span><br><span class="line">kubectl logs -f volume-emptydir -n dev -c busybox</span><br></pre></td></tr></table></figure>
<h5 id="HostPath"><a href="#HostPath" class="headerlink" title="HostPath"></a>HostPath</h5>想简单的将数据持久化到主机中，可以选择HostPath<br>HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。<br><img src="/image/docker/23.jpg" alt=" "><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DirectoryOrCreate 目录存在就使用，不存在就先创建后使用</span><br><span class="line">Directory 目录必须存在</span><br><span class="line">FileOrCreate 文件存在就使用，不存在就先创建后使用</span><br><span class="line">File 文件必须存在</span><br><span class="line">Socket unix套接字必须存在</span><br><span class="line">CharDevice 字符设备必须存在</span><br><span class="line">BlockDevice 块设备必须存在</span><br></pre></td></tr></table></figure>
<h5 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h5>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。<br>NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。<br><img src="/image/docker/24.jpg" alt=" "><h4 id="高级存储"><a href="#高级存储" class="headerlink" title="高级存储"></a>高级存储</h4>PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。<br>PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。<br><img src="/image/docker/25.jpg" alt=" "><h5 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h5>PV是存储资源的抽象，下面是资源清单文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv2</span><br><span class="line">spec:</span><br><span class="line">  nfs: <span class="comment"># 存储类型，与底层真正存储对应</span></span><br><span class="line">  capacity: <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    storage: 2Gi</span><br><span class="line">  accessModes: <span class="comment"># 访问模式</span></span><br><span class="line">  storageClassName: <span class="comment"># 存储类别</span></span><br><span class="line">  persistentVolumeReclaimPolicy: <span class="comment"># 回收策略</span></span><br></pre></td></tr></table></figure></li>
<li>存储类型<br>底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异</li>
<li>存储能力（capacity）<br>目前只支持存储空间的设置( storage&#x3D;1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置</li>
<li>访问模式（accessModes）<br>用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：<br><strong>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载<br>ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载<br>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</strong></li>
<li>回收策略（persistentVolumeReclaimPolicy）<br>当PV不再被使用了之后，对其的处理方式。目前支持三种策略：<br><strong>Retain （保留） 保留数据，需要管理员手工清理数据<br>Recycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf &#x2F;thevolume&#x2F; *<br>Delete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的</strong></li>
<li>存储类别<br>PV可以通过storageClassName参数指定一个存储类别<br>具有特定类别的PV只能与请求了该类别的PVC进行绑定<br>未设定类别的PV则只能与不请求任何类别的PVC进行绑定</li>
<li>状态（status）<br>一个 PV 的生命周期中，可能会处于4中不同的阶段：<br>Available（可用）： 表示可用状态，还未被任何 PVC 绑定<br>Bound（已绑定）： 表示 PV 已经被 PVC 绑定<br>Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明<br>Failed（失败）： 表示该 PV 的自动回收失败<h5 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h5>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  accessModes: <span class="comment"># 访问模式</span></span><br><span class="line">  selector: <span class="comment"># 采用标签对PV选择</span></span><br><span class="line">  storageClassName: <span class="comment"># 存储类别</span></span><br><span class="line">  resources: <span class="comment"># 请求空间</span></span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br></pre></td></tr></table></figure></li>
<li>访问模式（accessModes）<br>用于描述用户应用对存储资源的访问权限</li>
<li>选择条件（selector）<br>通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选</li>
<li>存储类别（storageClassName）<br>PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</li>
<li>资源请求（Resources ）<br>描述对存储资源的请求<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期<br>资源供应：管理员手动创建底层存储和PV<br>资源绑定：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定<br>在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了<br>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求<br>的PV<strong>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</strong><br>资源使用：用户可在pod中像volume一样使用pvc<br>Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。<br>资源释放：用户删除pvc来释放pv<br>当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。<br>资源回收：kubernetes根据pv设置的回收策略进行资源的回收<br>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用<h4 id="配置存储"><a href="#配置存储" class="headerlink" title="配置存储"></a>配置存储</h4><h5 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h5>ConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: configmap</span><br><span class="line">  namespace: dev</span><br><span class="line">data:</span><br><span class="line">  info:</span><br><span class="line">    username:admin</span><br><span class="line">    password:123456</span><br></pre></td></tr></table></figure>
<h5 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h5>Secret对象主要用于存储敏感信息，例如密码、秘钥、证书<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先使用base64对数据进行编码</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;admin&#x27;</span> | <span class="built_in">base64</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;123456&#x27;</span> | <span class="built_in">base64</span></span><br><span class="line"><span class="comment"># 接下来编写secret.yaml，并创建Secret</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: secret</span><br><span class="line">  namespace: dev</span><br><span class="line"><span class="built_in">type</span>: Opaque</span><br><span class="line">data:</span><br><span class="line">  username: YWRtaW4=</span><br><span class="line">  password: MTIzNDU2</span><br></pre></td></tr></table></figure>
<h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h3>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种客户端进行认证和鉴权操作。</li>
<li>客户端<br>User Account：一般是独立于kubernetes之外的其他服务管理的用户账号<br>Service Account：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识<br><img src="/image/docker/19.jpg" alt=" "></li>
<li>认证、授权与准入控制<br>Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证<br>Authorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作<br>Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能<br><img src="/image/docker/20.jpg" alt=" "><h4 id="认证管理"><a href="#认证管理" class="headerlink" title="认证管理"></a>认证管理</h4>Kubernetes集群安全的最关键点在于<strong>如何识别并认证客户端身份</strong></li>
<li>HTTP Base认证：通过用户名+密码的方式认证<br>把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。</li>
<li>HTTP Token认证：通过一个Token来识别合法用户<br>用一个很长的难以被模仿的字符串–Token来表明客户身份的一种方式。每个<br>Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。</li>
<li><strong>HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式</strong><br><img src="/image/docker/21.jpg" alt=" "><br>1.HTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者<br>2.客户端和服务端的双向认证<br>客户端向服务器端发起请求，服务端下发自己的证书给客户端，<br>客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥，<br>客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器<br>客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书，<br>在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法<br>3.服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密<h4 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h4>AlwaysDeny：表示拒绝所有请求，一般用于测试<br>AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）<br>ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制<br>Webhook：通过调用外部REST服务对用户进行授权<br>Node：是一种专用模式，用于对kubelet发出的请求进行访问控制<br>RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）<h5 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h5>Role、ClusterRole：角色，用于指定一组权限<br>RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Role只能对命名空间内的资源进行授权，需要指定nameapce</span></span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: dev</span><br><span class="line">  name: authorization-role</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>] <span class="comment"># 支持的API组列表,&quot;&quot; 空字符串，表示核心API群</span></span><br><span class="line">  resources: [<span class="string">&quot;pods&quot;</span>] <span class="comment"># 支持的资源对象列表</span></span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>] <span class="comment"># 允许的对资源对象的操作方法列表</span></span><br><span class="line"><span class="comment"># ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权</span></span><br><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: authorization-clusterrole</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  resources: [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>
<h4 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h4>准入控制是一个可配置的控制器列表，可以通过在Api-Server上通过命令行设置选择执行哪些准入控制器<br>AlwaysAdmit：允许所有请求<br>AlwaysDeny：禁止所有请求，一般用于测试<br>AlwaysPullImages：在启动容器之前总去下载镜像<br>DenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求<br>ImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。<br>Service Account：实现ServiceAccount实现了自动化<br>SecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效<br>ResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标<br>LimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制<br>InitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置<br>NamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象。<br>DefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节<br>DefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有<br>notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min<br>PodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的PodSecurityPolicy对Pod的安全策略进行控制<h3 id="DashBoard"><a href="#DashBoard" class="headerlink" title="DashBoard"></a>DashBoard</h3>kubernetes开发了一个基于web的用户界面（Dashboard）。用户可以使用Dashboard部署容器化的应用，还可以监控应用的状态，执行故障排查以及管理kubernetes中各种资源。<h4 id="部署Dashboard"><a href="#部署Dashboard" class="headerlink" title="部署Dashboard"></a>部署Dashboard</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml</span><br><span class="line"><span class="comment"># 修改kubernetes-dashboard的Service类型</span></span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># 新增</span></span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30009 <span class="comment"># 新增</span></span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">kubectl create -f recommended.yaml</span><br><span class="line"><span class="comment"># 创建账号</span></span><br><span class="line">kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard</span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin</span><br><span class="line"><span class="comment"># 获取token</span></span><br><span class="line">kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47058489/article/details/124409604">https://blog.csdn.net/qq_47058489/article/details/124409604</a><br>&#96;&#96;&#96;&#96;</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://xczf.shop">betty bear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xczf.shop/2022/04/01/kubernets/">http://xczf.shop/2022/04/01/kubernets/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xczf.shop" target="_blank">betty bear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a></div><div class="post_share"><div class="social-share" data-image="/image/36.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><img class="prev-cover" src="/image/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构(Python)</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/15/prometheus/"><img class="next-cover" src="/image/32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Prometheus</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/04/01/Docker/" title="Docker"><img class="cover" src="/image/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-01</div><div class="title">Docker</div></div></a></div><div><a href="/2023/10/01/DevOps/" title="devops"><img class="cover" src="/image/16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="title">devops</div></div></a></div><div><a href="/2021/04/15/KVM/" title="KVM"><img class="cover" src="/image/31.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-15</div><div class="title">KVM</div></div></a></div><div><a href="/2020/04/15/PXE/" title="PXE无人值守安装系统"><img class="cover" src="/image/28.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-15</div><div class="title">PXE无人值守安装系统</div></div></a></div><div><a href="/2021/06/01/Shell/" title="Shell"><img class="cover" src="/image/23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-01</div><div class="title">Shell</div></div></a></div><div><a href="/2023/07/15/OpenStack/" title="Openstack"><img class="cover" src="/image/25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-15</div><div class="title">Openstack</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">betty bear</div><div class="author-info__description">最在意的，或许得不到了</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/cate%EF%BC%9Agories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ccmmdd"><i class="fab fa-github"></i><span>不要点我呀！</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ccmmdd" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3025346417@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">你也不想这件事被发现吧！~~~///(^v^)\\\~~~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes"><span class="toc-number">1.</span> <span class="toc-text">Kubernetes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8kubernetes"><span class="toc-number">1.1.</span> <span class="toc-text">为什么使用kubernetes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernets-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">Kubernets 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">控制平面组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">Node组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">kubernetes网络模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85"><span class="toc-number">1.4.</span> <span class="toc-text">集群安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubernetes%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">kubernetes资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">资源对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%B5%84%E6%BA%90%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">对象资源格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">资源管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%EF%BC%9A%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%BB%E6%93%8D%E4%BD%9Ckubernetes%E8%B5%84%E6%BA%90"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">命令式对象管理：直接使用命令去操作kubernetes资源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%AF%B9%E8%B1%A1%E9%85%8D%E7%BD%AE%EF%BC%9A%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8E%BB%E6%93%8D%E4%BD%9Ckubernetes%E8%B5%84%E6%BA%90"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">命令式对象配置：通过命令配置和配置文件去操作kubernetes资源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AF%B9%E8%B1%A1%E9%85%8D%E7%BD%AE%EF%BC%9A%E9%80%9A%E8%BF%87apply%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8E%BB%E6%93%8D%E4%BD%9Ckubernetes%E8%B5%84%E6%BA%90"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">声明式对象配置：通过apply命令和配置文件去操作kubernetes资源</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Namespace"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">Namespace</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Pod"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">Pod</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Label"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">Label</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Service"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">Service</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8Epod%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">容器与pod资源对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pod%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">Pod资源清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86pod%E4%B8%AD%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">管理pod中容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%8F%8A%E5%85%B6%E8%8E%B7%E5%8F%96%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">镜像及其获取策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">暴露端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8C%96%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">自定义运行的容器化应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pod%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">pod资源限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E8%8A%82%E7%82%B9%E7%9A%84%E7%BD%91%E7%BB%9C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">1.6.2.6.</span> <span class="toc-text">共享节点的网络名称空间</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E4%B8%8E%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">标签与标签选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pod%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">pod节点选择器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pod%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.6.4.</span> <span class="toc-text">pod对象的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pod%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">pod的创建过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pod%E7%9A%84%E7%BB%88%E6%AD%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">pod的终止过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">钩子函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pod%E5%AD%98%E6%B4%BB%E6%80%A7%E6%8E%A2%E6%B5%8B"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">pod存活性探测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">容器的重启策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Pod%E8%B0%83%E5%BA%A6"><span class="toc-number">1.6.4.6.</span> <span class="toc-text">Pod调度</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E5%90%91%E8%B0%83%E5%BA%A6"><span class="toc-number">1.6.4.6.1.</span> <span class="toc-text">定向调度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%B2%E5%92%8C%E6%80%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">1.6.4.6.2.</span> <span class="toc-text">亲和性调度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">Pod控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReplicaSet-RS"><span class="toc-number">1.7.1.</span> <span class="toc-text">ReplicaSet(RS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deployment-Deploy"><span class="toc-number">1.7.2.</span> <span class="toc-text">Deployment(Deploy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Horizontal-Pod-Autoscaler-HPA"><span class="toc-number">1.7.3.</span> <span class="toc-text">Horizontal Pod Autoscaler(HPA)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DaemonSet-DS"><span class="toc-number">1.7.4.</span> <span class="toc-text">DaemonSet(DS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Job"><span class="toc-number">1.7.5.</span> <span class="toc-text">Job</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CronJob-CJ"><span class="toc-number">1.7.6.</span> <span class="toc-text">CronJob(CJ)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-1"><span class="toc-number">1.8.</span> <span class="toc-text">Service</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kube-proxy%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">kube-proxy工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#userspace-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">userspace 模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#iptables-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">iptables 模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ipvs-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">ipvs 模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">Service类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">Service使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ClusterIP%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">ClusterIP类型的Service</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HeadLess%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">HeadLess类型的Service</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NodePort%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">NodePort类型的Service</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LoadBalancer%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">LoadBalancer类型的Service</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ExternalName%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">1.8.3.5.</span> <span class="toc-text">ExternalName类型的Service</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ingress"><span class="toc-number">1.8.4.</span> <span class="toc-text">Ingress</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Ingress%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">Ingress使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.9.</span> <span class="toc-text">数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%98%E5%82%A8"><span class="toc-number">1.9.1.</span> <span class="toc-text">基本存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EmptyDir"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">EmptyDir</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HostPath"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">HostPath</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NFS"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">NFS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%AD%98%E5%82%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">高级存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PV"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">PV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PVC"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">PVC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.9.3.</span> <span class="toc-text">配置存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ConfigMap"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">ConfigMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Secret"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">Secret</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81"><span class="toc-number">1.10.</span> <span class="toc-text">安全认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E7%AE%A1%E7%90%86"><span class="toc-number">1.10.1.</span> <span class="toc-text">认证管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86"><span class="toc-number">1.10.2.</span> <span class="toc-text">授权管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RBAC"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">RBAC</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">1.10.3.</span> <span class="toc-text">准入控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DashBoard"><span class="toc-number">1.11.</span> <span class="toc-text">DashBoard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2Dashboard"><span class="toc-number">1.11.1.</span> <span class="toc-text">部署Dashboard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.11.2.</span> <span class="toc-text">使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/01/DevOps/" title="devops"><img src="/image/16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="devops"/></a><div class="content"><a class="title" href="/2023/10/01/DevOps/" title="devops">devops</a><time datetime="2023-10-01T11:00:41.000Z" title="发表于 2023-10-01 19:00:41">2023-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/01/memcache/" title="memcache"><img src="/image/27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="memcache"/></a><div class="content"><a class="title" href="/2023/09/01/memcache/" title="memcache">memcache</a><time datetime="2023-09-01T11:00:41.000Z" title="发表于 2023-09-01 19:00:41">2023-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/01/python-PyQt/" title="Python-PyQt"><img src="/image/33.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python-PyQt"/></a><div class="content"><a class="title" href="/2023/08/01/python-PyQt/" title="Python-PyQt">Python-PyQt</a><time datetime="2023-08-01T11:00:41.000Z" title="发表于 2023-08-01 19:00:41">2023-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/15/OpenStack/" title="Openstack"><img src="/image/25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Openstack"/></a><div class="content"><a class="title" href="/2023/07/15/OpenStack/" title="Openstack">Openstack</a><time datetime="2023-07-15T11:00:41.000Z" title="发表于 2023-07-15 19:00:41">2023-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/01/python-flask/" title="Python-Flask"><img src="/image/35.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python-Flask"/></a><div class="content"><a class="title" href="/2023/05/01/python-flask/" title="Python-Flask">Python-Flask</a><time datetime="2023-05-01T11:00:41.000Z" title="发表于 2023-05-01 19:00:41">2023-05-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/image/36.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By betty bear</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">啊，对对对!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://xczf.shop/2022/04/01/kubernets/'
    this.page.identifier = '2022/04/01/kubernets/'
    this.page.title = 'Kubernetes'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer src="/live2d-widget/autoload.js"></script><div class="aplayer no-destroy" data-id="8828254214" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>